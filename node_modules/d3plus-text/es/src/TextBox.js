function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
    @external BaseClass
    @see https://github.com/d3plus/d3plus-common#BaseClass
*/
import { select as _select } from "d3-selection";
import { transition } from "d3-transition";
import { max, min, sum } from "d3-array";
import { accessor, BaseClass, constant, parseSides } from "d3plus-common";
import fontExists from "./fontExists";
import { default as detectRTL } from "./rtl";
import strip from "./strip";
import textSplit from "./textSplit";
import measure from "./textWidth";
import wrap from "./textWrap";
import { trim, trimRight } from "./trim";
var defaultHtmlLookup = {
  i: "font-style: italic;",
  em: "font-style: italic;",
  b: "font-weight: bold;",
  strong: "font-weight: bold;"
};
/**
    @class TextBox
    @extends external:BaseClass
    @desc Creates a wrapped text box for each point in an array of data. See [this example](https://d3plus.org/examples/d3plus-text/getting-started/) for help getting started using the TextBox class.
*/

var TextBox = /*#__PURE__*/function (_BaseClass) {
  _inherits(TextBox, _BaseClass);

  var _super = _createSuper(TextBox);

  /**
      @memberof TextBox
      @desc Invoked when creating a new class instance, and sets any default parameters.
      @private
  */
  function TextBox() {
    var _this;

    _classCallCheck(this, TextBox);

    _this = _super.call(this);
    _this._ariaHidden = constant("false");
    _this._delay = 0;
    _this._duration = 0;

    _this._ellipsis = function (text, line) {
      return line ? "".concat(text.replace(/\.|,$/g, ""), "...") : "";
    };

    _this._fontColor = constant("black");
    _this._fontFamily = constant(["Roboto", "Helvetica Neue", "HelveticaNeue", "Helvetica", "Arial", "sans-serif"]);
    _this._fontMax = constant(50);
    _this._fontMin = constant(8);
    _this._fontOpacity = constant(1);
    _this._fontResize = constant(false);
    _this._fontSize = constant(10);
    _this._fontStroke = constant("transparent");
    _this._fontStrokeWidth = constant(0);
    _this._fontWeight = constant(400);
    _this._height = accessor("height", 200);
    _this._html = defaultHtmlLookup;

    _this._id = function (d, i) {
      return d.id || "".concat(i);
    };

    _this._lineHeight = function (d, i) {
      return _this._fontSize(d, i) * 1.2;
    };

    _this._maxLines = constant(null);
    _this._on = {};
    _this._overflow = constant(false);
    _this._padding = constant(0);
    _this._pointerEvents = constant("auto");
    _this._rotate = constant(0);

    _this._rotateAnchor = function (d) {
      return [d.w / 2, d.h / 2];
    };

    _this._split = textSplit;
    _this._text = accessor("text");
    _this._textAnchor = constant("start");
    _this._verticalAlign = constant("top");
    _this._width = accessor("width", 200);
    _this._x = accessor("x", 0);
    _this._y = accessor("y", 0);
    return _this;
  }
  /**
      @memberof TextBox
      @desc Renders the text boxes. If a *callback* is specified, it will be called once the shapes are done drawing.
      @param {Function} [*callback* = undefined]
  */


  _createClass(TextBox, [{
    key: "render",
    value: function render(callback) {
      var _this2 = this;

      if (this._select === void 0) this.select(_select("body").append("svg").style("width", "".concat(window.innerWidth, "px")).style("height", "".concat(window.innerHeight, "px")).node());
      var that = this;

      var boxes = this._select.selectAll(".d3plus-textBox").data(this._data.reduce(function (arr, d, i) {
        var t = _this2._text(d, i);

        if (t === void 0) return arr;
        t = trim(t);

        var resize = _this2._fontResize(d, i);

        var lHRatio = _this2._lineHeight(d, i) / _this2._fontSize(d, i);

        var fS = resize ? _this2._fontMax(d, i) : _this2._fontSize(d, i),
            lH = resize ? fS * lHRatio : _this2._lineHeight(d, i),
            line = 1,
            lineData = [],
            sizes,
            wrapResults;
        var style = {
          "font-family": fontExists(_this2._fontFamily(d, i)),
          "font-size": fS,
          "font-weight": _this2._fontWeight(d, i),
          "line-height": lH
        };
        var padding = parseSides(_this2._padding(d, i));
        var h = _this2._height(d, i) - (padding.top + padding.bottom),
            w = _this2._width(d, i) - (padding.left + padding.right);
        var wrapper = wrap().fontFamily(style["font-family"]).fontSize(fS).fontWeight(style["font-weight"]).lineHeight(lH).maxLines(_this2._maxLines(d, i)).height(h).overflow(_this2._overflow(d, i)).width(w).split(_this2._split);

        var fMax = _this2._fontMax(d, i),
            fMin = _this2._fontMin(d, i),
            vA = _this2._verticalAlign(d, i),
            words = _this2._split(t, i);
        /**
            Figures out the lineData to be used for wrapping.
            @private
        */


        function checkSize() {
          var truncate = function truncate() {
            if (line < 1) lineData = [that._ellipsis("", line)];else lineData[line - 1] = that._ellipsis(lineData[line - 1], line);
          }; // Constraint the font size


          fS = max([fS, fMin]);
          fS = min([fS, fMax]);

          if (resize) {
            lH = fS * lHRatio;
            wrapper.fontSize(fS).lineHeight(lH);
            style["font-size"] = fS;
            style["line-height"] = lH;
          }

          wrapResults = wrapper(t);
          lineData = wrapResults.lines.filter(function (l) {
            return l !== "";
          });
          line = lineData.length;

          if (wrapResults.truncated) {
            if (resize) {
              fS--;

              if (fS < fMin) {
                fS = fMin;
                truncate();
                return;
              } else checkSize();
            } else truncate();
          }
        }

        if (w > fMin && (h > lH || resize && h > fMin * lHRatio)) {
          if (resize) {
            sizes = measure(words, style);
            var areaMod = 1.165 + w / h * 0.1,
                boxArea = w * h,
                maxWidth = max(sizes),
                textArea = sum(sizes, function (d) {
              return d * lH;
            }) * areaMod;

            if (maxWidth > w || textArea > boxArea) {
              var areaRatio = Math.sqrt(boxArea / textArea),
                  widthRatio = w / maxWidth;
              var sizeRatio = min([areaRatio, widthRatio]);
              fS = Math.floor(fS * sizeRatio);
            }

            var heightMax = Math.floor(h * 0.8);
            if (fS > heightMax) fS = heightMax;
          }

          checkSize();
        }

        if (lineData.length) {
          var tH = line * lH;

          var r = _this2._rotate(d, i);

          var yP = r === 0 ? vA === "top" ? 0 : vA === "middle" ? h / 2 - tH / 2 : h - tH : 0;
          yP -= lH * 0.1;
          arr.push({
            aH: _this2._ariaHidden(d, i),
            data: d,
            i: i,
            lines: lineData,
            fC: _this2._fontColor(d, i),
            fStroke: _this2._fontStroke(d, i),
            fSW: _this2._fontStrokeWidth(d, i),
            fF: style["font-family"],
            fO: _this2._fontOpacity(d, i),
            fW: style["font-weight"],
            id: _this2._id(d, i),
            tA: _this2._textAnchor(d, i),
            vA: _this2._verticalAlign(d, i),
            widths: wrapResults.widths,
            fS: fS,
            lH: lH,
            w: w,
            h: h,
            r: r,
            x: _this2._x(d, i) + padding.left,
            y: _this2._y(d, i) + yP + padding.top
          });
        }

        return arr;
      }, []), function (d) {
        return _this2._id(d.data, d.i);
      });

      var t = transition().duration(this._duration);

      if (this._duration === 0) {
        boxes.exit().remove();
      } else {
        boxes.exit().transition().delay(this._duration).remove();
        boxes.exit().selectAll("text").transition(t).attr("opacity", 0).style("opacity", 0);
      }
      /**
       * Applies translate and rotate to a text element.
       * @param {D3Selection} text
       * @private
       */


      function rotate(text) {
        text.attr("transform", function (d, i) {
          var rotateAnchor = that._rotateAnchor(d, i);

          return "translate(".concat(d.x, ", ").concat(d.y, ") rotate(").concat(d.r, ", ").concat(rotateAnchor[0], ", ").concat(rotateAnchor[1], ")");
        });
      }

      var update = boxes.enter().append("g").attr("class", "d3plus-textBox").attr("id", function (d) {
        return "d3plus-textBox-".concat(strip(d.id));
      }).call(rotate).merge(boxes);
      var rtl = detectRTL();
      update.order().style("pointer-events", function (d) {
        return _this2._pointerEvents(d.data, d.i);
      }).each(function (d) {
        /**
            Sets the inner text content of each <text> element.
            @private
        */
        function textContent(text) {
          var tag = false;
          text[that._html ? "html" : "text"](function (t) {
            var cleaned = trimRight(t).replace(/&([^\;&]*)/g, function (str, a) {
              return a === "amp" ? str : "&amp;".concat(a);
            }) // replaces all non-HTML ampersands with escaped entity
            .replace(/<([^A-z^/]+)/g, function (str, a) {
              return "&lt;".concat(a);
            }).replace(/<$/g, "&lt;") // replaces all non-HTML left angle brackets with escaped entity
            .replace(/(<[^>^\/]+>)([^<^>]+)$/g, function (str, a, b) {
              return "".concat(a).concat(b).concat(a.replace("<", "</"));
            }) // ands end tag to lines before mid-HTML break
            .replace(/^([^<^>]+)(<\/[^>]+>)/g, function (str, a, b) {
              return "".concat(b.replace("</", "<")).concat(a).concat(b);
            }); // ands start tag to lines after mid-HTML break

            var tagRegex = new RegExp(/<([A-z]+)[^>]*>([^<^>]+)<\/[^>]+>/g);

            if (cleaned.match(tagRegex)) {
              cleaned = cleaned.replace(tagRegex, function (str, a, b) {
                tag = that._html[a] ? a : false;

                if (tag) {
                  var style = that._html[tag];
                  if (t.includes("</".concat(tag, ">"))) tag = false;
                  return "<tspan style=\"".concat(style, "\">").concat(b, "</tspan>");
                }

                return b;
              });
            } else if (tag.length) {
              cleaned = "<tspan style=\"".concat(that._html[tag], "\">").concat(cleaned, "</tspan>");
            }

            return cleaned;
          });
        }
        /**
            Styles to apply to each <text> element.
            @private
        */


        function textStyle(text) {
          text.attr("aria-hidden", d.aH).attr("dir", rtl ? "rtl" : "ltr").attr("fill", d.fC).attr("stroke", d.fStroke).attr("stroke-width", d.fSW).attr("text-anchor", d.tA).attr("font-family", d.fF).style("font-family", d.fF).attr("font-size", "".concat(d.fS, "px")).style("font-size", "".concat(d.fS, "px")).attr("font-weight", d.fW).style("font-weight", d.fW).attr("x", "".concat(d.tA === "middle" ? d.w / 2 : rtl ? d.tA === "start" ? d.w : 0 : d.tA === "end" ? d.w : 2 * Math.sin(Math.PI * d.r / 180), "px")).attr("y", function (t, i) {
            return d.r === 0 || d.vA === "top" ? "".concat((i + 1) * d.lH - (d.lH - d.fS), "px") : d.vA === "middle" ? "".concat((d.h + d.fS) / 2 - (d.lH - d.fS) + (i - d.lines.length / 2 + 0.5) * d.lH, "px") : "".concat(d.h - 2 * (d.lH - d.fS) - (d.lines.length - (i + 1)) * d.lH + 2 * Math.cos(Math.PI * d.r / 180), "px");
          });
        }

        var texts = _select(this).selectAll("text").data(d.lines);

        if (that._duration === 0) {
          texts.call(textContent).call(textStyle);
          texts.exit().remove();
          texts.enter().append("text").attr("dominant-baseline", "alphabetic").style("baseline-shift", "0%").attr("unicode-bidi", "bidi-override").call(textContent).call(textStyle).attr("opacity", d.fO).style("opacity", d.fO);
        } else {
          texts.call(textContent).transition(t).call(textStyle);
          texts.exit().transition(t).attr("opacity", 0).remove();
          texts.enter().append("text").attr("dominant-baseline", "alphabetic").style("baseline-shift", "0%").attr("opacity", 0).style("opacity", 0).call(textContent).call(textStyle).merge(texts).transition(t).delay(that._delay).call(textStyle).attr("opacity", d.fO).style("opacity", d.fO);
        }
      }).transition(t).call(rotate);
      var events = Object.keys(this._on),
          on = events.reduce(function (obj, e) {
        obj[e] = function (d, i) {
          return _this2._on[e](d.data, i);
        };

        return obj;
      }, {});

      for (var e = 0; e < events.length; e++) {
        update.on(events[e], on[events[e]]);
      }

      if (callback) setTimeout(callback, this._duration + 100);
      return this;
    }
    /**
        @memberof TextBox
        @desc If *value* is specified, sets the aria-hidden attribute to the specified function or string and returns the current class instance.
        @param {Function|String} *value*
        @chainable
    */

  }, {
    key: "ariaHidden",
    value: function ariaHidden(_) {
      return _ !== undefined ? (this._ariaHidden = typeof _ === "function" ? _ : constant(_), this) : this._ariaHidden;
    }
    /**
        @memberof TextBox
        @desc Sets the data array to the specified array. A text box will be drawn for each object in the array.
        @param {Array} [*data* = []]
        @chainable
    */

  }, {
    key: "data",
    value: function data(_) {
      return arguments.length ? (this._data = _, this) : this._data;
    }
    /**
        @memberof TextBox
        @desc Sets the animation delay to the specified number in milliseconds.
        @param {Number} [*value* = 0]
        @chainable
    */

  }, {
    key: "delay",
    value: function delay(_) {
      return arguments.length ? (this._delay = _, this) : this._delay;
    }
    /**
        @memberof TextBox
        @desc Sets the animation duration to the specified number in milliseconds.
        @param {Number} [*value* = 0]
        @chainable
    */

  }, {
    key: "duration",
    value: function duration(_) {
      return arguments.length ? (this._duration = _, this) : this._duration;
    }
    /**
        @memberof TextBox
        @desc Sets the function that handles what to do when a line is truncated. It should return the new value for the line, and is passed 2 arguments: the String of text for the line in question, and the number of the line. By default, an ellipsis is added to the end of any line except if it is the first word that cannot fit (in that case, an empty string is returned).
        @param {Function|String} [*value*]
        @chainable
        @example <caption>default accessor</caption>
    function(text, line) {
    return line ? text.replace(/\.|,$/g, "") + "..." : "";
    }
    */

  }, {
    key: "ellipsis",
    value: function ellipsis(_) {
      return arguments.length ? (this._ellipsis = typeof _ === "function" ? _ : constant(_), this) : this._ellipsis;
    }
    /**
        @memberof TextBox
        @desc Sets the font color to the specified accessor function or static string, which is inferred from the [DOM selection](#textBox.select) by default.
        @param {Function|String} [*value* = "black"]
        @chainable
    */

  }, {
    key: "fontColor",
    value: function fontColor(_) {
      return arguments.length ? (this._fontColor = typeof _ === "function" ? _ : constant(_), this) : this._fontColor;
    }
    /**
        @memberof TextBox
        @desc Defines the font-family to be used. The value passed can be either a *String* name of a font, a comma-separated list of font-family fallbacks, an *Array* of fallbacks, or a *Function* that returns either a *String* or an *Array*. If supplying multiple fallback fonts, the [fontExists](#fontExists) function will be used to determine the first available font on the client's machine.
        @param {Array|Function|String} [*value* = ["Roboto", "Helvetica Neue", "HelveticaNeue", "Helvetica", "Arial", "sans-serif"]]
        @chainable
    */

  }, {
    key: "fontFamily",
    value: function fontFamily(_) {
      return arguments.length ? (this._fontFamily = typeof _ === "function" ? _ : constant(_), this) : this._fontFamily;
    }
    /**
        @memberof TextBox
        @desc Sets the maximum font size to the specified accessor function or static number (which corresponds to pixel units), which is used when [dynamically resizing fonts](#textBox.fontResize).
        @param {Function|Number} [*value* = 50]
        @chainable
    */

  }, {
    key: "fontMax",
    value: function fontMax(_) {
      return arguments.length ? (this._fontMax = typeof _ === "function" ? _ : constant(_), this) : this._fontMax;
    }
    /**
        @memberof TextBox
        @desc Sets the minimum font size to the specified accessor function or static number (which corresponds to pixel units), which is used when [dynamically resizing fonts](#textBox.fontResize).
        @param {Function|Number} [*value* = 8]
        @chainable
    */

  }, {
    key: "fontMin",
    value: function fontMin(_) {
      return arguments.length ? (this._fontMin = typeof _ === "function" ? _ : constant(_), this) : this._fontMin;
    }
    /**
        @memberof TextBox
        @desc Sets the font opacity to the specified accessor function or static number between 0 and 1.
        @param {Function|Number} [*value* = 1]
        @chainable
     */

  }, {
    key: "fontOpacity",
    value: function fontOpacity(_) {
      return arguments.length ? (this._fontOpacity = typeof _ === "function" ? _ : constant(_), this) : this._fontOpacity;
    }
    /**
        @memberof TextBox
        @desc Toggles font resizing, which can either be defined as a static boolean for all data points, or an accessor function that returns a boolean. See [this example](http://d3plus.org/examples/d3plus-text/resizing-text/) for a side-by-side comparison.
        @param {Function|Boolean} [*value* = false]
        @chainable
    */

  }, {
    key: "fontResize",
    value: function fontResize(_) {
      return arguments.length ? (this._fontResize = typeof _ === "function" ? _ : constant(_), this) : this._fontResize;
    }
    /**
        @memberof TextBox
        @desc Sets the font size to the specified accessor function or static number (which corresponds to pixel units), which is inferred from the [DOM selection](#textBox.select) by default.
        @param {Function|Number} [*value* = 10]
        @chainable
    */

  }, {
    key: "fontSize",
    value: function fontSize(_) {
      return arguments.length ? (this._fontSize = typeof _ === "function" ? _ : constant(_), this) : this._fontSize;
    }
    /**
        @memberof TextBox
        @desc Sets the font stroke color for the rendered text.
        @param {Function|String} [*value* = "transparent"]
        @chainable
    */

  }, {
    key: "fontStroke",
    value: function fontStroke(_) {
      return arguments.length ? (this._fontStroke = typeof _ === "function" ? _ : constant(_), this) : this._fontStroke;
    }
    /**
        @memberof TextBox
        @desc Sets the font stroke width for the rendered text.
        @param {Function|Number} [*value* = 0]
        @chainable
    */

  }, {
    key: "fontStrokeWidth",
    value: function fontStrokeWidth(_) {
      return arguments.length ? (this._fontStrokeWidth = typeof _ === "function" ? _ : constant(_), this) : this._fontStrokeWidth;
    }
    /**
        @memberof TextBox
        @desc Sets the font weight to the specified accessor function or static number, which is inferred from the [DOM selection](#textBox.select) by default.
        @param {Function|Number|String} [*value* = 400]
        @chainable
    */

  }, {
    key: "fontWeight",
    value: function fontWeight(_) {
      return arguments.length ? (this._fontWeight = typeof _ === "function" ? _ : constant(_), this) : this._fontWeight;
    }
    /**
        @memberof TextBox
        @desc Sets the height for each box to the specified accessor function or static number.
        @param {Function|Number} [*value*]
        @chainable
        @example <caption>default accessor</caption>
    function(d) {
    return d.height || 200;
    }
    */

  }, {
    key: "height",
    value: function height(_) {
      return arguments.length ? (this._height = typeof _ === "function" ? _ : constant(_), this) : this._height;
    }
    /**
        @memberof TextBox
        @desc Configures the ability to render simple HTML tags. Defaults to supporting `<b>`, `<strong>`, `<i>`, and `<em>`, set to false to disable or provide a mapping of tags to svg styles
        @param {Object|Boolean} [*value* = {
                  i: 'font-style: italic;',
                  em: 'font-style: italic;',
                  b: 'font-weight: bold;',
                  strong: 'font-weight: bold;'
              }]
        @chainable
    */

  }, {
    key: "html",
    value: function html(_) {
      return arguments.length ? (this._html = typeof _ === "boolean" ? _ ? defaultHtmlLookup : false : _, this) : this._html;
    }
    /**
        @memberof TextBox
        @desc Defines the unique id for each box to the specified accessor function or static number.
        @param {Function|Number} [*value*]
        @chainable
        @example <caption>default accessor</caption>
    function(d, i) {
    return d.id || i + "";
    }
    */

  }, {
    key: "id",
    value: function id(_) {
      return arguments.length ? (this._id = typeof _ === "function" ? _ : constant(_), this) : this._id;
    }
    /**
        @memberof TextBox
        @desc Sets the line height to the specified accessor function or static number, which is 1.2 times the [font size](#textBox.fontSize) by default.
        @param {Function|Number} [*value*]
        @chainable
    */

  }, {
    key: "lineHeight",
    value: function lineHeight(_) {
      return arguments.length ? (this._lineHeight = typeof _ === "function" ? _ : constant(_), this) : this._lineHeight;
    }
    /**
        @memberof TextBox
        @desc Restricts the maximum number of lines to wrap onto, which is null (unlimited) by default.
        @param {Function|Number} [*value*]
        @chainable
    */

  }, {
    key: "maxLines",
    value: function maxLines(_) {
      return arguments.length ? (this._maxLines = typeof _ === "function" ? _ : constant(_), this) : this._maxLines;
    }
    /**
        @memberof TextBox
        @desc Sets the text overflow to the specified accessor function or static boolean.
        @param {Function|Boolean} [*value* = false]
        @chainable
    */

  }, {
    key: "overflow",
    value: function overflow(_) {
      return arguments.length ? (this._overflow = typeof _ === "function" ? _ : constant(_), this) : this._overflow;
    }
    /**
        @memberof TextBox
        @desc Sets the padding to the specified accessor function, CSS shorthand string, or static number, which is 0 by default.
        @param {Function|Number|String} [*value*]
        @chainable
    */

  }, {
    key: "padding",
    value: function padding(_) {
      return arguments.length ? (this._padding = typeof _ === "function" ? _ : constant(_), this) : this._padding;
    }
    /**
        @memberof TextBox
        @desc Sets the pointer-events to the specified accessor function or static string.
        @param {Function|String} [*value* = "auto"]
        @chainable
    */

  }, {
    key: "pointerEvents",
    value: function pointerEvents(_) {
      return arguments.length ? (this._pointerEvents = typeof _ === "function" ? _ : constant(_), this) : this._pointerEvents;
    }
    /**
        @memberof TextBox
        @desc Sets the rotate percentage for each box to the specified accessor function or static string.
        @param {Function|Number} [*value* = 0]
        @chainable
    */

  }, {
    key: "rotate",
    value: function rotate(_) {
      return arguments.length ? (this._rotate = typeof _ === "function" ? _ : constant(_), this) : this._rotate;
    }
    /**
        @memberof TextBox
        @desc Sets the anchor point around which to rotate the text box.
        @param {Function|Number[]}
        @chainable
     */

  }, {
    key: "rotateAnchor",
    value: function rotateAnchor(_) {
      return arguments.length ? (this._rotateAnchor = typeof _ === "function" ? _ : constant(_), this) : this._rotateAnchor;
    }
    /**
        @memberof TextBox
        @desc Sets the SVG container element to the specified d3 selector or DOM element. If not explicitly specified, an SVG element will be added to the page for use.
        @param {String|HTMLElement} [*selector*]
        @chainable
    */

  }, {
    key: "select",
    value: function select(_) {
      return arguments.length ? (this._select = _select(_), this) : this._select;
    }
    /**
        @memberof TextBox
        @desc Sets the word split behavior to the specified function, which when passed a string is expected to return that string split into an array of words.
        @param {Function} [*value*]
        @chainable
    */

  }, {
    key: "split",
    value: function split(_) {
      return arguments.length ? (this._split = _, this) : this._split;
    }
    /**
        @memberof TextBox
        @desc Sets the text for each box to the specified accessor function or static string.
        @param {Function|String} [*value*]
        @chainable
        @example <caption>default accessor</caption>
    function(d) {
    return d.text;
    }
    */

  }, {
    key: "text",
    value: function text(_) {
      return arguments.length ? (this._text = typeof _ === "function" ? _ : constant(_), this) : this._text;
    }
    /**
        @memberof TextBox
        @desc Sets the horizontal text anchor to the specified accessor function or static string, whose values are analagous to the SVG [text-anchor](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/text-anchor) property.
        @param {Function|String} [*value* = "start"]
        @chainable
    */

  }, {
    key: "textAnchor",
    value: function textAnchor(_) {
      return arguments.length ? (this._textAnchor = typeof _ === "function" ? _ : constant(_), this) : this._textAnchor;
    }
    /**
        @memberof TextBox
        @desc Sets the vertical alignment to the specified accessor function or static string. Accepts `"top"`, `"middle"`, and `"bottom"`.
        @param {Function|String} [*value* = "top"]
        @chainable
    */

  }, {
    key: "verticalAlign",
    value: function verticalAlign(_) {
      return arguments.length ? (this._verticalAlign = typeof _ === "function" ? _ : constant(_), this) : this._verticalAlign;
    }
    /**
        @memberof TextBox
        @desc Sets the width for each box to the specified accessor function or static number.
        @param {Function|Number} [*value*]
        @chainable
        @example <caption>default accessor</caption>
    function(d) {
    return d.width || 200;
    }
    */

  }, {
    key: "width",
    value: function width(_) {
      return arguments.length ? (this._width = typeof _ === "function" ? _ : constant(_), this) : this._width;
    }
    /**
        @memberof TextBox
        @desc Sets the x position for each box to the specified accessor function or static number. The number given should correspond to the left side of the textBox.
        @param {Function|Number} [*value*]
        @chainable
        @example <caption>default accessor</caption>
    function(d) {
    return d.x || 0;
    }
    */

  }, {
    key: "x",
    value: function x(_) {
      return arguments.length ? (this._x = typeof _ === "function" ? _ : constant(_), this) : this._x;
    }
    /**
        @memberof TextBox
        @desc Sets the y position for each box to the specified accessor function or static number. The number given should correspond to the top side of the textBox.
        @param {Function|Number} [*value*]
        @chainable
        @example <caption>default accessor</caption>
    function(d) {
    return d.y || 0;
    }
    */

  }, {
    key: "y",
    value: function y(_) {
      return arguments.length ? (this._y = typeof _ === "function" ? _ : constant(_), this) : this._y;
    }
  }]);

  return TextBox;
}(BaseClass);

export { TextBox as default };