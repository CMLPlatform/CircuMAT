function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
    @function configPrep
    @desc Preps a config object for d3plus data, and optionally bubbles up a specific nested type. When using this function, you must bind a d3plus class' `this` context.
    @param {Object} [config = this._shapeConfig] The configuration object to parse.
    @param {String} [type = "shape"] The event classifier to user for "on" events. For example, the default event type of "shape" will apply all events in the "on" config object with that key, like "click.shape" and "mouseleave.shape", in addition to any gloval events like "click" and "mouseleave".
    @param {String} [nest] An optional nested key to bubble up to the parent config level.
*/
export default function configPrep() {
  var _this = this;

  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._shapeConfig;
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "shape";
  var nest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var newConfig = {
    duration: this._duration,
    on: {}
  };

  var wrapFunction = function wrapFunction(func) {
    return function (d, i, s, e) {
      var parent;

      while (d.__d3plus__) {
        if (parent) d.__d3plusParent__ = parent;
        parent = d;
        i = d.i;
        d = d.data || d.feature;
      }

      return func.bind(_this)(d, i, s || parent, e);
    };
  };

  var parseEvents = function parseEvents(newObj, on) {
    for (var event in on) {
      if ({}.hasOwnProperty.call(on, event) && !event.includes(".") || event.includes(".".concat(type))) {
        newObj.on[event] = wrapFunction(on[event]);
      }
    }
  };

  var arrayEval = function arrayEval(arr) {
    return arr.map(function (d) {
      if (d instanceof Array) return arrayEval(d);else if (_typeof(d) === "object") return keyEval({}, d);else if (typeof d === "function") return wrapFunction(d);else return d;
    });
  };

  var keyEval = function keyEval(newObj, obj) {
    for (var key in obj) {
      if ({}.hasOwnProperty.call(obj, key)) {
        if (key === "on") parseEvents(newObj, obj[key]);else if (typeof obj[key] === "function") {
          newObj[key] = wrapFunction(obj[key]);
        } else if (obj[key] instanceof Array) {
          newObj[key] = arrayEval(obj[key]);
        } else if (_typeof(obj[key]) === "object") {
          if (!newObj[key]) newObj[key] = {};
          newObj[key].on = {};
          keyEval(newObj[key], obj[key]);
        } else newObj[key] = obj[key];
      }
    }
  };

  keyEval(newConfig, config);
  if (this._on) parseEvents(newConfig, this._on);

  if (nest && config[nest]) {
    keyEval(newConfig, config[nest]);
    if (config[nest].on) parseEvents(newConfig, config[nest].on);
  }

  return newConfig;
}