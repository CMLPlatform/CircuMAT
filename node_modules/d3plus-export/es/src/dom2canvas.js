function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import html2canvas from "html2canvas";
import canvg from "canvg-browser";
import { select, selectAll } from "d3-selection";
import svgPresets from "./svgPresets";
import htmlPresets from "./htmlPresets";
var defaultOptions = {
  background: false,
  callback: function callback() {},
  exclude: [],
  padding: 0,
  scale: 1
};
var canvgOptions = {
  ignoreMouse: true,
  ignoreAnimation: true,
  ignoreDimensions: true,
  ignoreClear: true
};
/**
    @function parseTransform
    @desc Extracts scale, x, and y position from an elements "transform" attribute, respecting cross-browser render differences.
    @param {HTMLElement} elem The element to be analyzed.
    @private
*/

function parseTransform(elem) {
  var property = select(elem).attr("transform");
  var scale = 1,
      x = 0,
      y = 0;

  if (property) {
    scale = property.match(/scale\(([^a-z]+)\)/i);
    if (scale) scale = parseFloat(scale[1]);else scale = 1;
    var translate = property.match(/translate\(([^a-z]+)\)/i);

    if (translate) {
      var _translate$1$replace$ = translate[1].replace(", ", ",").replace(/([^a-z]),*\s([^a-z])/gi, "$1,$2").split(",").map(function (d) {
        return parseFloat(d) * scale;
      });

      var _translate$1$replace$2 = _slicedToArray(_translate$1$replace$, 2);

      x = _translate$1$replace$2[0];
      y = _translate$1$replace$2[1];
    }
  }

  return [scale, x, y];
}
/**
    @function dom2canvas
    @desc Renders HTML/SVG elements to a shared canvas.
    @param {HTMLElement|Object|Array} elem The element or array of elements to be rendered to a single canvas. Additionally, a complex object can be passed as an element which can contain specific other properties.
    @param {Number} [elem.x] The x offset of the element within the rendered canvas.
    @param {Number} [elem.y] The y offset of the element within the rendered canvas.
    @param {Object} [options] Additional options to specify.
    @param {String} [options.background] Background color of the rendered canvas.
    @param {Function} [options.callback] Callback function to be passed the canvas element after rendering.
    @param {HTMLElement} [options.canvas] A canvas DOM element to draw onto. If no element is supplied, a canvas element will be created in memory and passed to the callback function when drawing is complete.
    @param {Array} [options.excludes] An array of HTMLElement objects to be excluded from the render.
    @param {Number} [options.height] Pixel height for the final output. If a height value has not been passed, it will be inferred from the sizing of the first DOM element passed.
    @param {Number} [options.padding = 0] Outer padding for the final file.
    @param {Number} [options.scale = 1] Scale for the final file.
    @param {Number} [options.width] Pixel width for the final output. If a width value has not been passed, it will be inferred from the sizing of the first DOM element passed.
*/


export default function (elem, options) {
  if (!elem) return;
  if (!(elem instanceof Array)) elem = [elem];
  options = Object.assign({}, defaultOptions, options);
  var IE = new RegExp(/(MSIE|Trident\/|Edge\/)/i).test(navigator.userAgent);
  var ratio = window ? window.devicePixelRatio || 1 : 1;
  var reference = elem[0];
  if (reference.constructor === Object) reference = reference.element;
  var height = options.height || parseFloat(select(reference).style("height")) + parseFloat(select(reference).style("padding-top")) + parseFloat(select(reference).style("padding-bottom")),
      width = options.width || parseFloat(select(reference).style("width")) + parseFloat(select(reference).style("padding-left")) + parseFloat(select(reference).style("padding-right"));
  var layerX,
      layerY,
      offsetX = 0,
      offsetY = 0;

  if (reference.getBoundingClientRect) {
    var bounds = reference.getBoundingClientRect();
    offsetX = bounds.left;
    offsetY = bounds.top;
  } else {
    offsetX = reference.offsetLeft;
    offsetY = reference.offsetTop;
  }

  var canvas = options.canvas || document.createElement("canvas");
  canvas.width = (width + options.padding * 2) * options.scale * ratio;
  canvas.height = (height + options.padding * 2) * options.scale * ratio;
  canvas.style.width = (width + options.padding * 2) * options.scale;
  canvas.style.height = (height + options.padding * 2) * options.scale;
  var context = canvas.getContext("2d");
  context.scale(options.scale * ratio, options.scale * ratio);
  context.clearRect(0, 0, canvas.width / ratio, canvas.height / ratio);

  if (options.background) {
    context.beginPath();
    context.rect(0, 0, canvas.width / ratio, canvas.height / ratio);
    context.fillStyle = options.background;
    context.fill();
  }

  var layers = [];
  /**
   * Determines how a given DOM element should be rendered.
   * @param {Object} trans ancestral transform properties
   * @private
   */

  function checkRender(trans) {
    var tag = (this.tagName || "").toLowerCase();
    if (options.exclude.includes(this) || tag === "foreignobject") return;
    var transform = Object.assign({}, trans); // strips translate and scale from transform property

    if (this.tagName) {
      var opacity = select(this).attr("opacity") || select(this).style("opacity");
      var display = select(this).style("display");
      var visibility = select(this).style("visibility");
      if (display === "none" || visibility === "hidden" || opacity && parseFloat(opacity) === 0) return;

      var _tag = this.tagName.toLowerCase();

      if (_tag.length && ["defs", "title", "desc"].includes(_tag)) return;

      if (_tag === "svg") {
        // do not perform this transform for SVGs nested within other SVGs
        if (!transform.svg) {
          var _this$getBoundingClie = this.getBoundingClientRect(),
              left = _this$getBoundingClie.left,
              top = _this$getBoundingClie.top;

          transform.x += left - offsetX;
          transform.y += top - offsetY;
          transform.svg = true;
        }

        var x = select(this).attr("x");
        x = x ? parseFloat(x) * transform.scale : 0;
        transform.x += x;
        var y = select(this).attr("y");
        y = y ? parseFloat(y) * transform.scale : 0;
        transform.y += y;
        transform.clip = {
          height: parseFloat(select(this).attr("height") || select(this).style("height")),
          width: parseFloat(select(this).attr("width") || select(this).style("width")),
          x: x,
          y: y
        };
      } else {
        var _x = select(this).attr("x");

        if (_x) transform.x += parseFloat(_x) * transform.scale;

        var _y = select(this).attr("y");

        if (_y) transform.y += parseFloat(_y) * transform.scale;
      }
    }

    if (!tag.length) {
      var test = (this.wholeText || "").replace(/\s/g, "");

      if (test.length) {
        var text = this.nodeValue.replace(/^\s*/, "").replace(/^\n/, "").replace(/^\s*/, "").replace(/\n$/, "").replace(/\s*$/, "").replace(/\n$/, "");
        layers.push({
          type: "text",
          style: this.parentNode,
          value: text,
          x: transform.x,
          y: transform.y
        });
      }
    } else if (tag === "text") {
      var _elem = this.cloneNode(true);

      select(_elem).call(svgPresets);
      layers.push(Object.assign({}, transform, {
        type: "svg",
        value: _elem
      }));
    } else if (["image", "img"].includes(tag)) {
      var url = select(this).attr("href") || select(this).attr("xlink:href");

      if (url.length) {
        var h = parseFloat(select(this).attr("height")) * transform.scale,
            w = parseFloat(select(this).attr("width")) * transform.scale;
        var data = {
          clip: transform.clip,
          height: h,
          loaded: false,
          type: "img",
          width: w,
          x: transform.x,
          y: transform.y
        };
        layers.push(data);
        var img = new Image();
        img.crossOrigin = "Anonymous";

        img.onload = function () {
          var canvas2 = document.createElement("canvas");
          var ctx2 = canvas2.getContext("2d");
          canvas2.height = h * ratio;
          canvas2.width = w * ratio;
          ctx2.drawImage(this, 0, 0, w * ratio, h * ratio);
          var himg = document.createElement("img");
          himg.src = canvas2.toDataURL("image/png");
          data.value = himg;
          data.loaded = true;
        };

        img.onerror = function () {
          data.loaded = true;
          data.value = false;
        };

        img.src = url;
      }
    } else if (!["svg", "g", "text"].includes(tag) && !select(this).selectAll("svg").size()) {
      var s = options.scale * ratio;
      var _data = {
        height: Math.floor(height + options.padding * 2 + offsetY),
        loaded: false,
        type: "html",
        width: Math.floor(width + options.padding * 2 + offsetX),
        x: Math.floor(layerX - offsetX),
        y: Math.floor(layerY - offsetY)
      };
      var tempCanvas = document.createElement("canvas");
      tempCanvas.width = _data.width * s;
      tempCanvas.height = _data.height * s;
      tempCanvas.style.width = "".concat(_data.width * s, "px");
      tempCanvas.style.height = "".concat(_data.height * s, "px");
      var tempContext = tempCanvas.getContext("2d");
      tempContext.scale(s, s);
      layers.push(_data);
      htmlPresets(select(this));
      html2canvas(this, {
        allowTaint: true,
        canvas: tempCanvas,
        letterRendering: true
      }).then(function (c) {
        _data.value = c;
        _data.loaded = true;
      });
    } else if (tag !== "svg" && this.childNodes.length > 0 && !select(this).selectAll("image, img, svg").size()) {
      var _elem2 = this.cloneNode(true);

      select(_elem2).selectAll("*").each(function () {
        select(this).call(svgPresets);
        if (select(this).attr("opacity") === "0") this.parentNode.removeChild(this);
      });
      layers.push(Object.assign({}, transform, {
        type: "svg",
        value: _elem2,
        tag: tag
      }));
    } else if (this.childNodes.length > 0) {
      var _parseTransform = parseTransform(this),
          _parseTransform2 = _slicedToArray(_parseTransform, 3),
          scale = _parseTransform2[0],
          _x2 = _parseTransform2[1],
          _y2 = _parseTransform2[2];

      transform.scale *= scale;
      transform.x += _x2;
      transform.y += _y2;
      checkChildren(this, transform);
    } else {
      // catches all SVG shapes
      var _elem3 = this.cloneNode(true);

      select(_elem3).selectAll("*").each(function () {
        if (select(this).attr("opacity") === "0") this.parentNode.removeChild(this);
      });

      if (tag === "line") {
        select(_elem3).attr("x1", parseFloat(select(_elem3).attr("x1")) + transform.x);
        select(_elem3).attr("x2", parseFloat(select(_elem3).attr("x2")) + transform.x);
        select(_elem3).attr("y1", parseFloat(select(_elem3).attr("y1")) + transform.y);
        select(_elem3).attr("y2", parseFloat(select(_elem3).attr("y2")) + transform.y);
      } else if (tag === "path") {
        var _parseTransform3 = parseTransform(_elem3),
            _parseTransform4 = _slicedToArray(_parseTransform3, 3),
            _scale = _parseTransform4[0],
            _x3 = _parseTransform4[1],
            _y3 = _parseTransform4[2];

        if (select(_elem3).attr("transform")) select(_elem3).attr("transform", "scale(".concat(_scale, ")translate(").concat(_x3 + transform.x, ",").concat(_y3 + transform.y, ")"));
      }

      select(_elem3).call(svgPresets);
      var fill = select(_elem3).attr("fill");
      var defFill = fill && fill.indexOf("url") === 0; // if (defFill) select(elem).attr("fill-opacity", 0);

      layers.push(Object.assign({}, transform, {
        type: "svg",
        value: _elem3,
        tag: tag
      }));

      if (defFill) {
        var def = select(fill.slice(4, -1)).node().cloneNode(true);
        var defTag = (def.tagName || "").toLowerCase();

        if (defTag === "pattern") {
          var _parseTransform5 = parseTransform(_elem3),
              _parseTransform6 = _slicedToArray(_parseTransform5, 3),
              _scale2 = _parseTransform6[0],
              _x4 = _parseTransform6[1],
              _y4 = _parseTransform6[2];

          transform.scale *= _scale2;
          transform.x += _x4;
          transform.y += _y4;
          checkChildren(def, transform);
        }
      }
    }
  }
  /**
   * Performs "checkRender" on all childNodes of a DOM element (used recursively by checkRender)
   * @param {HTMLElement} e DOM node to traverse
   * @param {Object} trans ancestral transform properties
   * @private
   */


  function checkChildren(e, trans) {
    selectAll(e.childNodes).each(function () {
      checkRender.bind(this)(trans);
    });
  }

  for (var i = 0; i < elem.length; i++) {
    var e = elem[i],
        _options = {
      scale: 1,
      x: 0,
      y: 0,
      svg: false
    };

    if (e.constructor === Object) {
      _options = Object.assign(_options, e);
      e = e.element;
    }

    layerX = _options.x;
    layerY = _options.y;
    checkRender.bind(e)(_options);
  }
  /**
   * Checks the status of each render layer every 500ms, and finishes render once all are complete.
   * @private
   */


  function checkStatus() {
    var allDone = true;

    for (var _i2 = 0; _i2 < layers.length; _i2++) {
      if (layers[_i2].loaded === false) {
        allDone = false;
        break;
      }
    }

    if (allDone) finish();else setTimeout(checkStatus, 500);
  }

  checkStatus();
  /**
   * Finishes the render after all layers have been rendered to canvas.
   * @private
   */

  function finish() {
    for (var _i3 = 0; _i3 < layers.length; _i3++) {
      var layer = layers[_i3];
      var clip = layer.clip || {
        height: height,
        width: width,
        x: 0,
        y: 0
      };

      switch (layer.type) {
        case "img":
          if (layer.value) {
            context.save();
            context.beginPath();
            context.translate(options.padding + clip.x, options.padding + clip.y);
            context.rect(0, 0, clip.width, clip.height);
            context.clip();
            context.drawImage(layer.value, layer.x + clip.x, layer.y + clip.y, layer.width, layer.height);
            context.restore();
          }

          break;

        case "html":
          context.save();
          context.beginPath();
          context.translate(options.padding, options.padding);
          context.drawImage(layer.value, layer.x, layer.y, layer.width, layer.height);
          context.restore();
          break;

        case "text":
          var parent = select(layer.style);
          var title = layer.value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
          var fC = parent.style("color"),
              fS = parent.style("font-size");
          var fF = parent.style("font-family").split(",")[0];
          if (fF.indexOf("'") !== 0) fF = "'".concat(fF, "'");
          var text = "<text stroke='none' dy='".concat(fS, "' fill='").concat(fC, "' font-family=").concat(fF, " font-size='").concat(fS, "'>").concat(title, "</text>");
          context.save();
          context.translate(options.padding, options.padding);
          canvg(canvas, text, Object.assign({}, canvgOptions, {
            offsetX: layer.x,
            offsetY: layer.y
          }));
          context.restore();
          break;

        case "svg":
          var outer = IE ? new XMLSerializer().serializeToString(layer.value) : layer.value.outerHTML;
          context.save();
          context.translate(options.padding + clip.x + layer.x, options.padding + clip.y + layer.y);
          context.rect(0, 0, clip.width, clip.height);
          context.clip();
          canvg(canvas, outer, Object.assign({}, canvgOptions, {
            offsetX: layer.x + clip.x,
            offsetY: layer.y + clip.y
          }));
          context.restore();
          break;

        default:
          console.warn("uncaught", layer);
          break;
      }
    }

    options.callback(canvas);
  }
}