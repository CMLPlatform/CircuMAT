function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
    @external BaseClass
    @see https://github.com/d3plus/d3plus-common#BaseClass
*/
import ckmeans from "./ckmeans";
import Legend from "./Legend";
import { extent, max, min, quantile, range, deviation } from "d3-array";
import { scaleLinear, scaleThreshold } from "d3-scale";
import { select as _select } from "d3-selection";
import { transition } from "d3-transition";
import { Axis } from "d3plus-axis";
import { colorDefaults, colorLighter } from "d3plus-color";
import { accessor, assign, BaseClass, constant, elem, unique } from "d3plus-common";
import { formatAbbreviate } from "d3plus-format";
import { Rect } from "d3plus-shape";
import { TextBox, textWidth } from "d3plus-text";
/**
    @class ColorScale
    @extends external:BaseClass
    @desc Creates an SVG scale based on an array of data. If *data* is specified, immediately draws based on the specified array and returns the current class instance. If *data* is not specified on instantiation, it can be passed/updated after instantiation using the [data](#shape.data) method.
*/

var ColorScale = /*#__PURE__*/function (_BaseClass) {
  _inherits(ColorScale, _BaseClass);

  var _super = _createSuper(ColorScale);

  /**
      @memberof ColorScale
      @desc Invoked when creating a new class instance, and sets any default parameters.
      @private
  */
  function ColorScale() {
    var _this;

    _classCallCheck(this, ColorScale);

    _this = _super.call(this);
    _this._axisClass = new Axis();
    _this._axisConfig = {
      gridSize: 0
    };
    _this._axisTest = new Axis();
    _this._align = "middle";
    _this._buckets = 5;
    _this._bucketAxis = false;

    _this._bucketFormat = function (tick, i, ticks, allValues) {
      var format = _this._axisConfig.tickFormat ? _this._axisConfig.tickFormat : formatAbbreviate;
      var next = ticks[i + 1];
      var prev = i ? ticks[i - 1] : false;
      var last = i === ticks.length - 1;

      if (tick === next || last) {
        var suffix = last && tick < max(allValues) ? "+" : "";
        return "".concat(format(tick)).concat(suffix);
      } else {
        var mod = next ? next / 100 : tick / 100;
        var pow = mod >= 1 || mod <= -1 ? Math.round(mod).toString().length - 1 : mod.toString().split(".")[1].replace(/([1-9])[1-9].*$/, "$1").length * -1;
        var ten = Math.pow(10, pow);
        var prevValue = prev === tick && i === 1 ? format(min([tick + ten, allValues.find(function (d) {
          return d > tick && d < next;
        })])) : format(tick);
        var nextValue = tick && i === 1 ? format(next) : format(max([next - ten, allValues.reverse().find(function (d) {
          return d > tick && d < next;
        })]));
        return _this._bucketJoiner(prevValue, nextValue);
      }
    };

    _this._bucketJoiner = function (a, b) {
      return a !== b ? "".concat(a, " - ").concat(b) : "".concat(a);
    };

    _this._centered = true;
    _this._color = ["#54478C", "#2C699A", "#0DB39E", "#83E377", "#EFEA5A"];
    _this._colorMax = colorDefaults.on;
    _this._colorMid = colorDefaults.light;
    _this._colorMin = colorDefaults.off;
    _this._data = [];
    _this._duration = 600;
    _this._height = 200;
    _this._labelClass = new TextBox();
    _this._labelConfig = {
      fontColor: colorDefaults.dark,
      fontSize: 12
    };
    _this._legendClass = new Legend();
    _this._legendConfig = {
      shapeConfig: {
        stroke: colorDefaults.dark,
        strokeWidth: 1
      }
    };
    _this._midpoint = 0;
    _this._orient = "bottom";
    _this._outerBounds = {
      width: 0,
      height: 0,
      x: 0,
      y: 0
    };
    _this._padding = 5;
    _this._rectClass = new Rect().parent(_assertThisInitialized(_this));
    _this._rectConfig = {
      stroke: "#999",
      strokeWidth: 1
    };
    _this._scale = "linear";
    _this._size = 10;
    _this._value = accessor("value");
    _this._width = 400;
    return _this;
  }
  /**
      @memberof ColorScale
      @desc Renders the current ColorScale to the page. If a *callback* is specified, it will be called once the ColorScale is done drawing.
      @param {Function} [*callback* = undefined]
      @chainable
  */


  _createClass(ColorScale, [{
    key: "render",
    value: function render(callback) {
      var _this2 = this;

      if (this._select === void 0) this.select(_select("body").append("svg").attr("width", "".concat(this._width, "px")).attr("height", "".concat(this._height, "px")).node());
      var horizontal = ["bottom", "top"].includes(this._orient);
      var height = horizontal ? "height" : "width",
          width = horizontal ? "width" : "height",
          x = horizontal ? "x" : "y",
          y = horizontal ? "y" : "x"; // Shape <g> Group

      this._group = elem("g.d3plus-ColorScale", {
        parent: this._select
      });

      var allValues = this._data.map(this._value).filter(function (d) {
        return d !== null && typeof d === "number";
      }).sort(function (a, b) {
        return a - b;
      });

      var domain = this._domain || extent(allValues);
      var negative = domain[0] < this._midpoint;
      var positive = domain[1] > this._midpoint;
      var diverging = negative && positive;
      var numBuckets = min([this._buckets instanceof Array ? this._buckets.length : this._buckets, unique(allValues).length]);
      var colors = this._color,
          labels,
          ticks;

      if (colors && !(colors instanceof Array)) {
        colors = range(0, numBuckets, 1).map(function (i) {
          return colorLighter(colors, (i + 1) / numBuckets);
        }).reverse();
      }

      if (this._scale === "jenks") {
        var buckets = min([colors ? colors.length : numBuckets, numBuckets, allValues.length]);
        var jenks = [];

        if (this._buckets instanceof Array) {
          ticks = this._buckets;
        } else {
          if (diverging && this._centered) {
            var half = Math.floor(buckets / 2);
            var residual = buckets % 2;
            var negatives = allValues.filter(function (d) {
              return d < _this2._midpoint;
            });
            var negativesDeviation = deviation(negatives);
            var positives = allValues.concat(this._midpoint).filter(function (d) {
              return d >= _this2._midpoint;
            });
            var positivesDeviation = deviation(positives);
            var isNegativeMax = negativesDeviation > positivesDeviation ? 1 : 0;
            var isPositiveMax = positivesDeviation > negativesDeviation ? 1 : 0;
            var negativeJenks = ckmeans(negatives, half + residual * isNegativeMax);
            var positiveJenks = ckmeans(positives, half + residual * isPositiveMax);
            jenks = negativeJenks.concat(positiveJenks);
          } else {
            jenks = ckmeans(allValues, buckets);
          }

          ticks = jenks.map(function (c) {
            return c[0];
          });
        }

        var tickSet = new Set(ticks);

        if (ticks.length !== tickSet.size) {
          labels = Array.from(tickSet);
        }

        if (!colors) {
          if (diverging) {
            colors = [this._colorMin, this._colorMid, this._colorMax];

            var _negatives = ticks.slice(0, buckets).filter(function (d, i) {
              return d < _this2._midpoint && ticks[i + 1] <= _this2._midpoint;
            });

            var spanning = ticks.slice(0, buckets).filter(function (d, i) {
              return d <= _this2._midpoint && ticks[i + 1] > _this2._midpoint;
            });

            var _positives = ticks.slice(0, buckets).filter(function (d, i) {
              return d > _this2._midpoint && ticks[i + 1] > _this2._midpoint;
            });

            var negativeColors = _negatives.map(function (d, i) {
              return !i ? colors[0] : colorLighter(colors[0], i / _negatives.length);
            });

            var spanningColors = spanning.map(function () {
              return colors[1];
            });

            var positiveColors = _positives.map(function (d, i) {
              return i === _positives.length - 1 ? colors[2] : colorLighter(colors[2], 1 - (i + 1) / _positives.length);
            });

            colors = negativeColors.concat(spanningColors).concat(positiveColors);
          } else {
            colors = range(0, numBuckets, 1).map(function (i) {
              return colorLighter(_this2._colorMax, i / numBuckets);
            }).reverse();
          }
        }

        if (allValues.length <= buckets) {
          colors = colors.slice(buckets - allValues.length);
        }

        colors = [colors[0]].concat(colors);
        this._colorScale = scaleThreshold().domain(ticks).range(colors);
      } else {
        var _buckets = this._buckets instanceof Array ? this._buckets : undefined;

        if (diverging && !colors) {
          var _half = Math.floor(numBuckets / 2);

          var _negativeColors = range(0, _half, 1).map(function (i) {
            return !i ? _this2._colorMin : colorLighter(_this2._colorMin, i / _half);
          });

          var _spanningColors = (numBuckets % 2 ? [0] : []).map(function () {
            return _this2._colorMid;
          });

          var _positiveColors = range(0, _half, 1).map(function (i) {
            return !i ? _this2._colorMax : colorLighter(_this2._colorMax, i / _half);
          }).reverse();

          colors = _negativeColors.concat(_spanningColors).concat(_positiveColors);

          if (!_buckets) {
            var step = (colors.length - 1) / 2;
            _buckets = [domain[0], this._midpoint, domain[1]];
            _buckets = range(domain[0], this._midpoint, -(domain[0] - this._midpoint) / step).concat(range(this._midpoint, domain[1], (domain[1] - this._midpoint) / step)).concat([domain[1]]);
          }
        } else {
          if (!colors) {
            if (this._scale === "buckets" || this._scale === "quantile") {
              colors = range(0, numBuckets, 1).map(function (i) {
                return colorLighter(negative ? _this2._colorMin : _this2._colorMax, i / numBuckets);
              });
              if (positive) colors = colors.reverse();
            } else {
              colors = negative ? [this._colorMin, colorLighter(this._colorMin, 0.8)] : [colorLighter(this._colorMax, 0.8), this._colorMax];
            }
          }

          if (!_buckets) {
            if (this._scale === "quantile") {
              var _step = 1 / (colors.length - 1);

              _buckets = range(0, 1 + _step / 2, _step).map(function (d) {
                return quantile(allValues, d);
              });
            } else if (diverging && this._color && this._centered) {
              var negativeStep = (this._midpoint - domain[0]) / Math.floor(colors.length / 2);
              var positiveStep = (domain[1] - this._midpoint) / Math.floor(colors.length / 2);
              var negativeBuckets = range(domain[0], this._midpoint, negativeStep);
              var positiveBuckets = range(this._midpoint, domain[1] + positiveStep / 2, positiveStep);
              _buckets = negativeBuckets.concat(positiveBuckets);
            } else {
              var _step2 = (domain[1] - domain[0]) / (colors.length - 1);

              _buckets = range(domain[0], domain[1] + _step2 / 2, _step2);
            }
          }
        }

        if (this._scale === "buckets" || this._scale === "quantile") {
          ticks = _buckets;
          colors = [colors[0]].concat(colors);
        } else if (this._scale === "log") {
          var _negativeBuckets = _buckets.filter(function (d) {
            return d < 0;
          });

          if (_negativeBuckets.length) {
            var minVal = _negativeBuckets[0];

            var newNegativeBuckets = _negativeBuckets.map(function (d) {
              return -Math.pow(Math.abs(minVal), d / minVal);
            });

            _negativeBuckets.forEach(function (bucket, i) {
              _buckets[_buckets.indexOf(bucket)] = newNegativeBuckets[i];
            });
          }

          var _positiveBuckets = _buckets.filter(function (d) {
            return d > 0;
          });

          if (_positiveBuckets.length) {
            var maxVal = _positiveBuckets[_positiveBuckets.length - 1];

            var newPositiveBuckets = _positiveBuckets.map(function (d) {
              return Math.pow(maxVal, d / maxVal);
            });

            _positiveBuckets.forEach(function (bucket, i) {
              _buckets[_buckets.indexOf(bucket)] = newPositiveBuckets[i];
            });
          }

          if (_buckets.includes(0)) _buckets[_buckets.indexOf(0)] = 1;
        }

        this._colorScale = (this._scale === "buckets" || this._scale === "quantile" ? scaleThreshold : scaleLinear)().domain(_buckets).range(colors);
      }

      if (this._colorScale.clamp) this._colorScale.clamp(true);
      var gradient = this._bucketAxis || !["buckets", "jenks", "quantile"].includes(this._scale);
      var t = transition().duration(this._duration);
      var groupParams = {
        enter: {
          opacity: 0
        },
        exit: {
          opacity: 0
        },
        parent: this._group,
        transition: t,
        update: {
          opacity: 1
        }
      };
      var labelGroup = elem("g.d3plus-ColorScale-labels", Object.assign({
        condition: gradient
      }, groupParams));
      var rectGroup = elem("g.d3plus-ColorScale-Rect", Object.assign({
        condition: gradient
      }, groupParams));
      var legendGroup = elem("g.d3plus-ColorScale-legend", Object.assign({
        condition: !gradient
      }, groupParams));

      if (gradient) {
        var _assign;

        var offsets = {
          x: 0,
          y: 0
        };
        var axisDomain = domain.slice();

        if (this._bucketAxis) {
          var last = axisDomain[axisDomain.length - 1];
          var prev = axisDomain[axisDomain.length - 2];
          var mod = last ? last / 10 : prev / 10;
          var pow = mod >= 1 || mod <= -1 ? Math.round(mod).toString().length - 1 : mod.toString().split(".")[1].replace(/([1-9])[1-9].*$/, "$1").length * -1;
          var ten = Math.pow(10, pow);
          axisDomain[axisDomain.length - 1] = last + ten;
        }

        var axisConfig = assign({
          domain: horizontal ? axisDomain : axisDomain.slice().reverse(),
          duration: this._duration,
          height: this._height,
          labels: labels || ticks,
          orient: this._orient,
          padding: this._padding,
          scale: this._scale === "log" ? "log" : "linear",
          ticks: ticks,
          width: this._width
        }, this._axisConfig);
        var labelConfig = assign({
          height: this["_".concat(height)] / 2,
          width: this["_".concat(width)] / 2
        }, this._labelConfig);

        this._labelClass.config(labelConfig);

        var labelData = [];

        if (horizontal && this._labelMin) {
          var labelCSS = {
            "font-family": this._labelClass.fontFamily()(this._labelMin),
            "font-size": this._labelClass.fontSize()(this._labelMin),
            "font-weight": this._labelClass.fontWeight()(this._labelMin)
          };
          if (labelCSS["font-family"] instanceof Array) labelCSS["font-family"] = labelCSS["font-family"][0];
          var labelMinWidth = textWidth(this._labelMin, labelCSS);

          if (labelMinWidth && labelMinWidth < this["_".concat(width)] / 2) {
            labelData.push(this._labelMin);
            labelMinWidth += this._padding;
            if (horizontal) offsets.x += labelMinWidth;
            axisConfig[width] -= labelMinWidth;
          }
        }

        if (horizontal && this._labelMax) {
          var _labelCSS = {
            "font-family": this._labelClass.fontFamily()(this._labelMax),
            "font-size": this._labelClass.fontSize()(this._labelMax),
            "font-weight": this._labelClass.fontWeight()(this._labelMax)
          };
          if (_labelCSS["font-family"] instanceof Array) _labelCSS["font-family"] = _labelCSS["font-family"][0];
          var labelMaxWidth = textWidth(this._labelMax, _labelCSS);

          if (labelMaxWidth && labelMaxWidth < this["_".concat(width)] / 2) {
            labelData.push(this._labelMax);
            labelMaxWidth += this._padding;
            if (!horizontal) offsets.y += labelMaxWidth;
            axisConfig[width] -= labelMaxWidth;
          }
        }

        this._axisTest.select(elem("g.d3plus-ColorScale-axisTest", {
          enter: {
            opacity: 0
          },
          parent: this._group
        }).node()).config(axisConfig).duration(0).render();

        var axisBounds = this._axisTest.outerBounds();

        this._outerBounds[width] = this["_".concat(width)] - this._padding * 2;
        this._outerBounds[height] = axisBounds[height] + this._size;
        this._outerBounds[x] = this._padding;
        this._outerBounds[y] = this._padding;
        if (this._align === "middle") this._outerBounds[y] = (this["_".concat(height)] - this._outerBounds[height]) / 2;else if (this._align === "end") this._outerBounds[y] = this["_".concat(height)] - this._padding - this._outerBounds[height];

        var axisGroupOffset = this._outerBounds[y] + (["bottom", "right"].includes(this._orient) ? this._size : 0) - (axisConfig.padding || this._axisClass.padding());

        var transform = "translate(".concat(offsets.x + (horizontal ? 0 : axisGroupOffset), ", ").concat(offsets.y + (horizontal ? axisGroupOffset : 0), ")");

        this._axisClass.select(elem("g.d3plus-ColorScale-axis", assign(groupParams, {
          condition: true,
          enter: {
            transform: transform
          },
          update: {
            transform: transform
          }
        })).node()).config(axisConfig).align("start").render();

        var axisScale = this._axisTest._getPosition.bind(this._axisTest);

        var scaleRange = this._axisTest._getRange();

        var defs = this._group.selectAll("defs").data([0]);

        var defsEnter = defs.enter().append("defs");
        defsEnter.append("linearGradient").attr("id", "gradient-".concat(this._uuid));
        defs = defsEnter.merge(defs);
        defs.select("linearGradient").attr("".concat(x, "1"), horizontal ? "0%" : "100%").attr("".concat(x, "2"), horizontal ? "100%" : "0%").attr("".concat(y, "1"), "0%").attr("".concat(y, "2"), "0%");
        var stops = defs.select("linearGradient").selectAll("stop").data(colors);

        var scaleDomain = this._colorScale.domain();

        var offsetScale = scaleLinear().domain(scaleRange).range(horizontal ? [0, 100] : [100, 0]);
        stops.enter().append("stop").merge(stops).attr("offset", function (d, i) {
          return "".concat(i <= scaleDomain.length - 1 ? offsetScale(axisScale(scaleDomain[i])) : 100, "%");
        }).attr("stop-color", String);
        /** determines the width of buckets */

        var bucketWidth = function bucketWidth(d, i) {
          var next = ticks[i + 1] || axisDomain[axisDomain.length - 1];
          return Math.abs(axisScale(next) - axisScale(d));
        };

        var rectConfig = assign((_assign = {
          duration: this._duration,
          fill: ticks ? function (d) {
            return _this2._colorScale(d);
          } : "url(#gradient-".concat(this._uuid, ")")
        }, _defineProperty(_assign, x, ticks ? function (d, i) {
          return axisScale(d) + bucketWidth(d, i) / 2 - (["left", "right"].includes(_this2._orient) ? bucketWidth(d, i) : 0);
        } : scaleRange[0] + (scaleRange[1] - scaleRange[0]) / 2 + offsets[x]), _defineProperty(_assign, y, this._outerBounds[y] + (["top", "left"].includes(this._orient) ? axisBounds[height] : 0) + this._size / 2 + offsets[y]), _defineProperty(_assign, width, ticks ? bucketWidth : scaleRange[1] - scaleRange[0]), _defineProperty(_assign, height, this._size), _assign), this._rectConfig);

        this._rectClass.data(ticks || [0]).id(function (d, i) {
          return i;
        }).select(rectGroup.node()).config(rectConfig).render();

        labelConfig.height = this._outerBounds[height];
        labelConfig.width = this._outerBounds[width];

        this._labelClass.config(labelConfig).data(labelData).select(labelGroup.node()).x(function (d) {
          return d === _this2._labelMax ? rectConfig.x + rectConfig.width / 2 + _this2._padding : _this2._outerBounds.x;
        }).y(function (d) {
          return rectConfig.y - _this2._labelClass.fontSize()(d) / 2;
        }).text(function (d) {
          return d;
        }).rotate(horizontal ? 0 : this._orient === "right" ? 90 : -90).render();
      } else {
        elem("g.d3plus-ColorScale-axis", Object.assign({
          condition: gradient
        }, groupParams));
        var legendData = ticks.reduce(function (arr, tick, i) {
          var label = _this2._bucketFormat.bind(_this2)(tick, i, ticks, allValues);

          arr.push({
            color: colors[i + 1],
            id: label
          });
          return arr;
        }, []);
        if (!horizontal) legendData = legendData.reverse();
        var legendConfig = assign({
          align: horizontal ? "center" : {
            start: "left",
            middle: "center",
            end: "right"
          }[this._align],
          direction: horizontal ? "row" : "column",
          duration: this._duration,
          height: this._height,
          padding: this._padding,
          shapeConfig: assign({
            duration: this._duration
          }, this._axisConfig.shapeConfig || {}),
          title: this._axisConfig.title,
          titleConfig: this._axisConfig.titleConfig || {},
          width: this._width,
          verticalAlign: horizontal ? {
            start: "top",
            middle: "middle",
            end: "bottom"
          }[this._align] : "middle"
        }, this._legendConfig);

        this._legendClass.data(legendData).select(legendGroup.node()).config(legendConfig).render();

        this._outerBounds = this._legendClass.outerBounds();
      }

      if (callback) setTimeout(callback, this._duration + 100);
      return this;
    }
    /**
        @memberof ColorScale
        @desc The [ColorScale](http://d3plus.org/docs/#ColorScale) is constructed by combining an [Axis](http://d3plus.org/docs/#Axis) for the ticks/labels and a [Rect](http://d3plus.org/docs/#Rect) for the actual color box (or multiple boxes, as in a jenks scale). Because of this, there are separate configs for the [Axis](http://d3plus.org/docs/#Axis) class used to display the text ([axisConfig](http://d3plus.org/docs/#ColorScale.axisConfig)) and the [Rect](http://d3plus.org/docs/#Rect) class used to draw the color breaks ([rectConfig](http://d3plus.org/docs/#ColorScale.rectConfig)). This method acts as a pass-through to the config method of the [Axis](http://d3plus.org/docs/#Axis). An example usage of this method can be seen [here](http://d3plus.org/examples/d3plus-legend/colorScale-dark/).
        @param {Object} [*value*]
        @chainable
    */

  }, {
    key: "axisConfig",
    value: function axisConfig(_) {
      return arguments.length ? (this._axisConfig = assign(this._axisConfig, _), this) : this._axisConfig;
    }
    /**
        @memberof ColorScale
        @desc If *value* is specified, sets the horizontal alignment to the specified value and returns the current class instance. If *value* is not specified, returns the current horizontal alignment.
        @param {String} [*value* = "center"] Supports `"left"` and `"center"` and `"right"`.
        @chainable
    */

  }, {
    key: "align",
    value: function align(_) {
      return arguments.length ? (this._align = _, this) : this._align;
    }
    /**
        @memberof ColorScale
        @desc The number of discrete buckets to create in a bucketed color scale. Will be overridden by any custom Array of colors passed to the `color` method. Optionally, users can supply an Array of values used to separate buckets, such as `[0, 10, 25, 50, 90]` for a percentage scale. This value would create 4 buckets, with each value representing the break point between each bucket (so 5 values makes 4 buckets).
        @param {Number|Array} [*value* = 5]
        @chainable
    */

  }, {
    key: "buckets",
    value: function buckets(_) {
      return arguments.length ? (this._buckets = _, this) : this._buckets;
    }
    /**
        @memberof ColorScale
        @desc Determines whether or not to use an Axis to display bucket scales (both "buckets" and "jenks"). When set to `false`, bucketed scales will use the `Legend` class to display squares for each range of data. When set to `true`, bucketed scales will be displayed on an `Axis`, similar to "linear" scales.
        @param {Boolean} [*value* = false]
        @chainable
    */

  }, {
    key: "bucketAxis",
    value: function bucketAxis(_) {
      return arguments.length ? (this._bucketAxis = _, this) : this._bucketAxis;
    }
    /**
        @memberof ColorScale
        @desc A function for formatting the labels associated to each bucket in a bucket-type scale ("jenks", "quantile", etc). The function is passed four arguments: the start value of the current bucket, it's index in the full Array of buckets, the full Array of buckets, and an Array of every value present in the data used to construct the buckets. Keep in mind that the end value for the bucket is not actually the next bucket in the list, but includes every value up until that next bucket value (less than, but not equal to). By default, d3plus will make the end value slightly less than it's current value, so that it does not overlap with the start label for the next bucket.
        @param {Function} [*value*]
        @chainable
    */

  }, {
    key: "bucketFormat",
    value: function bucketFormat(_) {
      return arguments.length ? (this._bucketFormat = _, this) : this._bucketFormat;
    }
    /**
        @memberof ColorScale
        @desc A function that receives the minimum and maximum values of a bucket, and is expected to return the full label.
        @param {Function} [*value*]
        @chainable
    */

  }, {
    key: "bucketJoiner",
    value: function bucketJoiner(_) {
      return arguments.length ? (this._bucketJoiner = _, this) : this._bucketJoiner;
    }
    /**
        @memberof ColorScale
        @desc Determines whether or not to display a midpoint centered Axis. Does not apply to quantile scales.
        @param {Boolean} [*value* = false]
        @chainable
    */

  }, {
    key: "centered",
    value: function centered(_) {
      return arguments.length ? (this._centered = _, this) : this._centered;
    }
    /**
        @memberof ColorScale
        @desc Overrides the default internal logic of `colorMin`, `colorMid`, and `colorMax` to only use just this specified color. If a single color is given as a String, then the scale is interpolated by lightening that color. Otherwise, the function expects an Array of color values to be used in order for the scale.
        @param {String|Array} [*value*]
        @chainable
    */

  }, {
    key: "color",
    value: function color(_) {
      return arguments.length ? (this._color = _, this) : this._color;
    }
    /**
        @memberof ColorScale
        @desc Defines the color to be used for numbers greater than the value of the `midpoint` on the scale (defaults to `0`). Colors in between this value and the value of `colorMid` will be interpolated, unless a custom Array of colors has been specified using the `color` method.
        @param {String} [*value* = "#0C8040"]
        @chainable
    */

  }, {
    key: "colorMax",
    value: function colorMax(_) {
      return arguments.length ? (this._colorMax = _, this) : this._colorMax;
    }
    /**
        @memberof ColorScale
        @desc Defines the color to be used for the midpoint of a diverging scale, based on the current value of the `midpoint` method (defaults to `0`). Colors in between this value and the values of `colorMin` and `colorMax` will be interpolated, unless a custom Array of colors has been specified using the `color` method.
        @param {String} [*value* = "#f7f7f7"]
        @chainable
    */

  }, {
    key: "colorMid",
    value: function colorMid(_) {
      return arguments.length ? (this._colorMid = _, this) : this._colorMid;
    }
    /**
        @memberof ColorScale
        @desc Defines the color to be used for numbers less than the value of the `midpoint` on the scale (defaults to `0`). Colors in between this value and the value of `colorMid` will be interpolated, unless a custom Array of colors has been specified using the `color` method.
        @param {String} [*value* = "#b22200"]
        @chainable
    */

  }, {
    key: "colorMin",
    value: function colorMin(_) {
      return arguments.length ? (this._colorMin = _, this) : this._colorMin;
    }
    /**
        @memberof ColorScale
        @desc If *data* is specified, sets the data array to the specified array and returns the current class instance. If *data* is not specified, returns the current data array. A shape key will be drawn for each object in the array.
        @param {Array} [*data* = []]
        @chainable
    */

  }, {
    key: "data",
    value: function data(_) {
      return arguments.length ? (this._data = _, this) : this._data;
    }
    /**
        @memberof ColorScale
        @desc In a linear scale, this Array of 2 values defines the min and max values used in the color scale. Any values outside of this range will be mapped to the nearest color value.
        @param {Array} [*value*]
        @chainable
    */

  }, {
    key: "domain",
    value: function domain(_) {
      return arguments.length ? (this._domain = _, this) : this._domain;
    }
    /**
        @memberof ColorScale
        @desc If *value* is specified, sets the transition duration of the ColorScale and returns the current class instance. If *value* is not specified, returns the current duration.
        @param {Number} [*value* = 600]
        @chainable
    */

  }, {
    key: "duration",
    value: function duration(_) {
      return arguments.length ? (this._duration = _, this) : this._duration;
    }
    /**
        @memberof ColorScale
        @desc If *value* is specified, sets the overall height of the ColorScale and returns the current class instance. If *value* is not specified, returns the current height value.
        @param {Number} [*value* = 100]
        @chainable
    */

  }, {
    key: "height",
    value: function height(_) {
      return arguments.length ? (this._height = _, this) : this._height;
    }
    /**
        @memberof ColorScale
        @desc A pass-through for the [TextBox](http://d3plus.org/docs/#TextBox) class used to style the labelMin and labelMax text.
        @param {Object} [*value*]
        @chainable
    */

  }, {
    key: "labelConfig",
    value: function labelConfig(_) {
      return arguments.length ? (this._labelConfig = assign(this._labelConfig, _), this) : this._labelConfig;
    }
    /**
        @memberof ColorScale
        @desc Defines a text label to be displayed off of the end of the minimum point in the scale (currently only available in horizontal orientation).
        @param {String} [*value*]
        @chainable
    */

  }, {
    key: "labelMin",
    value: function labelMin(_) {
      return arguments.length ? (this._labelMin = _, this) : this._labelMin;
    }
    /**
        @memberof ColorScale
        @desc Defines a text label to be displayed off of the end of the maximum point in the scale (currently only available in horizontal orientation).
        @param {String} [*value*]
        @chainable
    */

  }, {
    key: "labelMax",
    value: function labelMax(_) {
      return arguments.length ? (this._labelMax = _, this) : this._labelMax;
    }
    /**
        @memberof ColorScale
        @desc The [ColorScale](http://d3plus.org/docs/#ColorScale) is constructed by combining an [Axis](http://d3plus.org/docs/#Axis) for the ticks/labels and a [Rect](http://d3plus.org/docs/#Rect) for the actual color box (or multiple boxes, as in a jenks scale). Because of this, there are separate configs for the [Axis](http://d3plus.org/docs/#Axis) class used to display the text ([axisConfig](http://d3plus.org/docs/#ColorScale.axisConfig)) and the [Rect](http://d3plus.org/docs/#Rect) class used to draw the color breaks ([rectConfig](http://d3plus.org/docs/#ColorScale.rectConfig)). This method acts as a pass-through to the config method of the [Axis](http://d3plus.org/docs/#Axis). An example usage of this method can be seen [here](http://d3plus.org/examples/d3plus-legend/colorScale-dark/).
        @param {Object} [*value*]
        @chainable
    */

  }, {
    key: "legendConfig",
    value: function legendConfig(_) {
      return arguments.length ? (this._legendConfig = assign(this._legendConfig, _), this) : this._legendConfig;
    }
    /**
        @memberof ColorScale
        @desc The number value to be used as the anchor for `colorMid`, and defines the center point of the diverging color scale.
        @param {Number} [*value* = 0]
        @chainable
    */

  }, {
    key: "midpoint",
    value: function midpoint(_) {
      return arguments.length ? (this._midpoint = _, this) : this._midpoint;
    }
    /**
        @memberof ColorScale
        @desc Sets the flow of the items inside the ColorScale. If no value is passed, the current flow will be returned.
        @param {String} [*value* = "bottom"]
        @chainable
    */

  }, {
    key: "orient",
    value: function orient(_) {
      return arguments.length ? (this._orient = _, this) : this._orient;
    }
    /**
        @memberof ColorScale
        @desc If called after the elements have been drawn to DOM, will returns the outer bounds of the ColorScale content.
        @example
    {"width": 180, "height": 24, "x": 10, "y": 20}
    */

  }, {
    key: "outerBounds",
    value: function outerBounds() {
      return this._outerBounds;
    }
    /**
        @memberof ColorScale
        @desc If *value* is specified, sets the padding between each key to the specified number and returns the current class instance. If *value* is not specified, returns the current padding value.
        @param {Number} [*value* = 10]
        @chainable
    */

  }, {
    key: "padding",
    value: function padding(_) {
      return arguments.length ? (this._padding = _, this) : this._padding;
    }
    /**
        @memberof ColorScale
        @desc The [ColorScale](http://d3plus.org/docs/#ColorScale) is constructed by combining an [Axis](http://d3plus.org/docs/#Axis) for the ticks/labels and a [Rect](http://d3plus.org/docs/#Rect) for the actual color box (or multiple boxes, as in a jenks scale). Because of this, there are separate configs for the [Axis](http://d3plus.org/docs/#Axis) class used to display the text ([axisConfig](http://d3plus.org/docs/#ColorScale.axisConfig)) and the [Rect](http://d3plus.org/docs/#Rect) class used to draw the color breaks ([rectConfig](http://d3plus.org/docs/#ColorScale.rectConfig)). This method acts as a pass-through to the config method of the [Rect](http://d3plus.org/docs/#Rect). An example usage of this method can be seen [here](http://d3plus.org/examples/d3plus-legend/colorScale-dark/).
        @param {Object} [*value*]
        @chainable
    */

  }, {
    key: "rectConfig",
    value: function rectConfig(_) {
      return arguments.length ? (this._rectConfig = assign(this._rectConfig, _), this) : this._rectConfig;
    }
    /**
        @memberof ColorScale
        @desc If *value* is specified, sets the scale of the ColorScale and returns the current class instance. If *value* is not specified, returns the current scale value.
        @param {String} [*value* = "linear"] Can either be "linear", "jenks", or "buckets".
        @chainable
    */

  }, {
    key: "scale",
    value: function scale(_) {
      return arguments.length ? (this._scale = _, this) : this._scale;
    }
    /**
        @memberof ColorScale
        @desc If *selector* is specified, sets the SVG container element to the specified d3 selector or DOM element and returns the current class instance. If *selector* is not specified, returns the current SVG container element.
        @param {String|HTMLElement} [*selector* = d3.select("body").append("svg")]
        @chainable
    */

  }, {
    key: "select",
    value: function select(_) {
      return arguments.length ? (this._select = _select(_), this) : this._select;
    }
    /**
        @memberof ColorScale
        @desc The height of horizontal color scales, and width when positioned vertical.
        @param {Number} [*value* = 10]
        @chainable
    */

  }, {
    key: "size",
    value: function size(_) {
      return arguments.length ? (this._size = _, this) : this._size;
    }
    /**
        @memberof ColorScale
        @desc If *value* is specified, sets the value accessor to the specified function or string and returns the current class instance. If *value* is not specified, returns the current value accessor.
        @param {Function|String} [*value*]
        @chainable
        @example
    function value(d) {
    return d.value;
    }
    */

  }, {
    key: "value",
    value: function value(_) {
      return arguments.length ? (this._value = typeof _ === "function" ? _ : constant(_), this) : this._value;
    }
    /**
        @memberof ColorScale
        @desc If *value* is specified, sets the overall width of the ColorScale and returns the current class instance. If *value* is not specified, returns the current width value.
        @param {Number} [*value* = 400]
        @chainable
    */

  }, {
    key: "width",
    value: function width(_) {
      return arguments.length ? (this._width = _, this) : this._width;
    }
  }]);

  return ColorScale;
}(BaseClass);

export { ColorScale as default };