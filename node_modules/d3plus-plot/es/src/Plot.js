function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* eslint no-cond-assign: 0 */
import { deviation, extent, max, mean, merge, min, range, sum } from "d3-array";
import { nest } from "d3-collection";
import * as scales from "d3-scale";
import * as d3Shape from "d3-shape";
import { AxisBottom, AxisLeft, AxisRight, AxisTop, date } from "d3plus-axis";
import { colorAssign, colorContrast, colorDefaults, colorLegible } from "d3plus-color";
import { accessor, assign, configPrep, constant, elem, RESET, unique } from "d3plus-common";
import { formatDate } from "d3plus-format";
import * as shapes from "d3plus-shape";
import { textWidth, TextBox } from "d3plus-text";
var testLineShape = new shapes.Line();
var testTextBox = new TextBox();
import { Viz } from "d3plus-viz";
import { default as BarBuffer } from "./buffers/Bar.js";
import { default as BoxBuffer } from "./buffers/Box.js";
import { default as CircleBuffer } from "./buffers/Circle.js";
import { default as LineBuffer } from "./buffers/Line.js";
import { default as RectBuffer } from "./buffers/Rect.js";
/**
    @desc Logic for determining default sizes of shapes using the sizeScaleD3 internal function.
    @private
*/

function defaultSize(d) {
  return this._sizeScaleD3(this._size ? this._size(d) : null);
}
/**
    @desc Logic for determining stackOrder ascending using groups.
    @private
*/


function stackOrderAscending(series) {
  var sums = series.map(stackSum);
  var keys = series.map(function (d) {
    return d.key.split("_")[0];
  });
  return d3Shape.stackOrderNone(series).sort(function (a, b) {
    return keys[b].localeCompare(keys[a]) || sums[a] - sums[b];
  });
}
/**
    @desc Logic for determining stackOrder descending using groups.
    @private
*/


function stackOrderDescending(series) {
  return stackOrderAscending(series).reverse();
}
/**
    @desc Logic for determining default sum of shapes using the stackSum function used in d3Shape.
    @private
*/


function stackSum(series) {
  var i = -1,
      s = 0,
      v;
  var n = series.length;

  while (++i < n) {
    if (v = +series[i][1]) s += v;
  }

  return s;
}
/**
    @desc Logic for determining default sum of shapes using the stackSum function used in d3Shape.
    @private
*/


function stackOffsetDiverging(series, order) {
  var n;
  if (!((n = series.length) > 0)) return;
  var d, dy, i, yn, yp;
  var m = series[order[0]].length;

  for (var j = 0; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
}
/**
 * Determines if a Bar label should be placed outside of the Bar.
 * @param {@} d
 * @param {*} i
 * @private
 */


function outside(d, i) {
  if (this._stacked) return false;
  var other = this._discrete.charAt(0) === "x" ? "y" : "x";

  var nonDiscrete = this._discrete.replace(this._discrete.charAt(0), other);

  var range = this["_".concat(nonDiscrete, "Axis")]._d3Scale.range();

  var value = this["_".concat(nonDiscrete)](d, i);
  var negative = value < 0;

  var zero = this["_".concat(nonDiscrete, "Axis")]._getPosition(0);

  var space = nonDiscrete === "y" ? negative ? range[1] - zero : zero - range[0] : negative ? zero - range[0] : range[1] - zero;

  var pos = this["_".concat(nonDiscrete, "Axis")]._getPosition(value);

  var size = Math.abs(pos - zero);
  return size < space / 2;
}
/**
    @class Plot
    @extends Viz
    @desc Creates an x/y plot based on an array of data.
*/


var Plot = /*#__PURE__*/function (_Viz) {
  _inherits(Plot, _Viz);

  var _super = _createSuper(Plot);

  /**
      @memberof Plot
      @desc Invoked when creating a new class instance, and sets any default parameters.
      @private
  */
  function Plot() {
    var _this;

    _classCallCheck(this, Plot);

    _this = _super.call(this);
    _this._annotations = [];
    _this._backgroundConfig = {
      duration: 0,
      fill: "transparent"
    };
    _this._barPadding = 0;
    _this._buffer = {
      Bar: BarBuffer,
      Box: BoxBuffer,
      Circle: CircleBuffer,
      Line: LineBuffer,
      Rect: RectBuffer
    };
    _this._confidenceConfig = {
      fill: function fill(d, i) {
        var c = typeof _this._shapeConfig.Line.stroke === "function" ? _this._shapeConfig.Line.stroke(d, i) : _this._shapeConfig.Line.stroke;
        return c;
      },
      fillOpacity: constant(0.5)
    };
    _this._discreteCutoff = 100;
    _this._groupPadding = 5;
    _this._lineMarkerConfig = {
      fill: function fill(d, i) {
        return colorAssign(_this._id(d, i));
      },
      r: constant(3)
    };
    _this._lineMarkers = false;
    _this._previousShapes = [];
    _this._shape = constant("Circle");
    _this._shapeConfig = assign(_this._shapeConfig, {
      Area: {
        label: function label(d, i) {
          return _this._stacked ? _this._drawLabel(d, i) : false;
        },
        labelBounds: function labelBounds(d, i, aes) {
          var r = shapes.largestRect(aes.points, {
            angle: range(-20, 20, 5)
          });
          if (!r || r.height < 20 || r.width < 50) r = shapes.largestRect(aes.points, {
            angle: range(-80, 80, 5)
          });
          if (!r) return null;
          var x = min(aes.points, function (d) {
            return d[0];
          });
          var y = max(aes.points.filter(function (d) {
            return d[0] === x;
          }), function (d) {
            return d[1];
          });
          return {
            angle: r.angle,
            width: r.width,
            height: r.height,
            x: r.cx - r.width / 2 - x,
            y: r.cy - r.height / 2 - y
          };
        },
        labelConfig: {
          fontMin: 6,
          fontResize: true,
          padding: 10
        }
      },
      ariaLabel: function ariaLabel(d, i) {
        var ariaLabelStr = "";
        if (d.nested) ariaLabelStr = "".concat(_this._drawLabel(d.data, d.i));else {
          ariaLabelStr = "".concat(_this._drawLabel(d, i));
          if (_this._x(d, i) !== undefined) ariaLabelStr += ", x: ".concat(_this._x(d, i));
          if (_this._y(d, i) !== undefined) ariaLabelStr += ", y: ".concat(_this._y(d, i));
          if (_this._x2(d, i) !== undefined) ariaLabelStr += ", x2: ".concat(_this._x2(d, i));
          if (_this._y2(d, i) !== undefined) ariaLabelStr += ", y2: ".concat(_this._y2(d, i));
        }
        return "".concat(ariaLabelStr, ".");
      },
      Bar: {
        labelBounds: function labelBounds(d, i, s) {
          var _ref2;

          var padding = 1;
          var width = this._discrete === "y" ? "width" : "height";
          var height = this._discrete === "y" ? "height" : "width";
          var other = this._discrete.charAt(0) === "x" ? "y" : "x";
          var invert = other === "y";

          var nonDiscrete = this._discrete.replace(this._discrete.charAt(0), other);

          var range = this["_".concat(nonDiscrete, "Axis")]._d3Scale.range();

          var space = Math.abs(range[1] - range[0]);
          var negative = this["_".concat(nonDiscrete)](d, i) < 0;

          if (outside.bind(this)(d, i)) {
            var _ref;

            return _ref = {}, _defineProperty(_ref, width, space - s[width]), _defineProperty(_ref, height, s[height]), _defineProperty(_ref, "x", invert ? -s.width / 2 : negative ? -space : s.width + padding), _defineProperty(_ref, "y", invert ? negative ? s.height + padding : -space : -s.height / 2 + 1), _ref;
          }

          return _ref2 = {}, _defineProperty(_ref2, width, s[width]), _defineProperty(_ref2, height, s[height]), _defineProperty(_ref2, "x", invert ? -s.width / 2 : negative ? this._stacked ? padding : padding - s.width : -padding), _defineProperty(_ref2, "y", invert ? negative ? this._stacked ? padding - s.height : padding : -s.height + padding : -s.height / 2 + padding), _ref2;
        },
        labelConfig: {
          fontMax: 16,
          fontMin: 6,
          fontResize: true,
          fontColor: function fontColor(d, i) {
            return outside.bind(this)(d, i) ? this._backgroundConfig.fill === "transparent" ? colorDefaults.dark : colorContrast(this._backgroundConfig.fill) : colorContrast(typeof this._shapeConfig.fill === "function" ? this._shapeConfig.fill(d, i) : this._shapeConfig.fill);
          },
          fontStroke: function fontStroke(d, i) {
            return outside.bind(this)(d, i) ? this._backgroundConfig.fill === "transparent" ? colorDefaults.dark : colorContrast(this._backgroundConfig.fill) : "transparent";
          },
          fontStrokeWidth: function fontStrokeWidth(d, i) {
            return outside.bind(this)(d, i) ? 0.1 : 0;
          },
          padding: 3,
          textAnchor: function textAnchor(d, i) {
            var other = this._discrete.charAt(0) === "x" ? "y" : "x";
            var invert = other === "y";

            var nonDiscrete = this._discrete.replace(this._discrete.charAt(0), other);

            var negative = this["_".concat(nonDiscrete)](d, i) < 0;
            return invert ? "middle" : outside.bind(this)(d, i) ? negative ? "end" : "start" : negative ? "start" : "end";
          },
          verticalAlign: function verticalAlign(d, i) {
            var other = this._discrete.charAt(0) === "x" ? "y" : "x";
            var invert = other === "y";

            var nonDiscrete = this._discrete.replace(this._discrete.charAt(0), other);

            var negative = this["_".concat(nonDiscrete)](d, i) < 0;
            return invert ? outside.bind(this)(d, i) ? negative ? "top" : "bottom" : negative ? "bottom" : "top" : "middle";
          }
        }
      },
      Circle: {
        r: defaultSize.bind(_assertThisInitialized(_this))
      },
      Line: {
        curve: function curve() {
          return _this._discrete ? "monotone".concat(_this._discrete.charAt(0).toUpperCase()) : "linear";
        },
        fill: constant("none"),
        labelConfig: {
          fontColor: function fontColor(d, i) {
            var c = typeof _this._shapeConfig.Line.stroke === "function" ? _this._shapeConfig.Line.stroke(d, i) : _this._shapeConfig.Line.stroke;
            return colorLegible(c);
          },
          fontResize: false,
          padding: 5,
          textAnchor: "start",
          verticalAlign: "middle"
        },
        stroke: function stroke(d, i) {
          return colorAssign(_this._id(d, i));
        },
        strokeWidth: constant(2)
      },
      Rect: {
        height: function height(d) {
          return defaultSize.bind(_assertThisInitialized(_this))(d) * 2;
        },
        width: function width(d) {
          return defaultSize.bind(_assertThisInitialized(_this))(d) * 2;
        }
      }
    });
    _this._shapeOrder = ["Area", "Path", "Bar", "Box", "Line", "Rect", "Circle"];

    _this._shapeSort = function (a, b) {
      return _this._shapeOrder.indexOf(a) - _this._shapeOrder.indexOf(b);
    };

    _this._sizeMax = 20;
    _this._sizeMin = 5;
    _this._sizeScale = "sqrt";
    _this._stackOffset = stackOffsetDiverging;
    _this._stackOrder = stackOrderDescending;
    _this._timelineConfig = assign(_this._timelineConfig, {
      brushing: true
    });
    _this._x = accessor("x");
    _this._xAxis = new AxisBottom().align("end");
    _this._xTest = new AxisBottom().align("end").gridSize(0);
    _this._xConfig = {
      gridConfig: {
        stroke: function stroke(d) {
          if (_this._discrete && _this._discrete.charAt(0) === "x") return "transparent";

          var range = _this._xAxis.range(); // hides left-most x gridline so it doesn't overlap with the y axis


          return range[0] === _this._xAxis._getPosition.bind(_this._xAxis)(d.id) ? "transparent" : "#eee";
        }
      }
    };
    _this._xCutoff = 150;
    _this._x2 = accessor("x2");
    _this._x2Axis = new AxisTop().align("start");
    _this._x2Test = new AxisTop().align("start").gridSize(0);
    _this._x2Config = {
      padding: 0
    };
    _this._y = accessor("y");
    _this._yAxis = new AxisLeft().align("start");
    _this._yTest = new AxisLeft().align("start").gridSize(0);
    _this._yConfig = {
      gridConfig: {
        stroke: function stroke(d) {
          if (_this._discrete && _this._discrete.charAt(0) === "y") return "transparent";

          var range = _this._yAxis.range(); // hides bottom-most y gridline so it doesn't overlap with the x axis


          return range[range.length - 1] === _this._yAxis._getPosition.bind(_this._yAxis)(d.id) ? "transparent" : "#eee";
        }
      }
    };
    _this._yCutoff = 150;
    _this._y2 = accessor("y2");
    _this._y2Axis = new AxisRight().align("end");
    _this._y2Test = new AxisLeft().align("end").gridSize(0);
    _this._y2Config = {};
    return _this;
  }
  /**
      Extends the preDraw behavior of the abstract Viz class.
      @private
  */


  _createClass(Plot, [{
    key: "_preDraw",
    value: function _preDraw() {
      var _this2 = this;

      // logic repeated for each axis
      ["x", "y", "x2", "y2"].forEach(function (k) {
        // if user has supplied a String key as the main method value
        if (_this2["_".concat(k, "Key")]) {
          var str = _this2["_".concat(k, "Key")]; // if axis is discrete and numerical, do not sum values


          if (!_this2._aggs[str] && _this2._discrete === k) {
            _this2._aggs[str] = function (a, c) {
              var v = Array.from(new Set(a.map(c)));
              return v.length === 1 ? v[0] : v;
            };
          } // set axis title if not discrete


          if (str !== k && _this2["_".concat(k, "Title")] === _this2["_".concat(k, "Config")].title && _this2._discrete !== k) {
            _this2["_".concat(k, "Title")] = str;
            _this2["_".concat(k, "Config")].title = str;
          }
        }
      });

      _get(_getPrototypeOf(Plot.prototype), "_preDraw", this).call(this);
    }
    /**
        Extends the draw behavior of the abstract Viz class.
        @private
    */

  }, {
    key: "_draw",
    value: function _draw(callback) {
      var _this3 = this;

      if (!this._filteredData.length) return this;

      var stackGroup = function stackGroup(d, i) {
        return _this3._stacked ? "".concat(_this3._groupBy.length > 1 ? _this3._ids(d, i).slice(0, -1).join("_") : "group") : "".concat(_this3._ids(d, i).join("_"));
      };

      var data = this._filteredData.map(function (d, i) {
        return {
          __d3plus__: true,
          data: d,
          group: stackGroup(d, i),
          i: i,
          hci: _this3._confidence && _this3._confidence[1] && _this3._confidence[1](d, i),
          id: _this3._ids(d, i).slice(0, _this3._drawDepth + 1).join("_"),
          lci: _this3._confidence && _this3._confidence[0] && _this3._confidence[0](d, i),
          shape: _this3._shape(d, i),
          x: _this3._x(d, i),
          x2: _this3._x2(d, i),
          y: _this3._y(d, i),
          y2: _this3._y2(d, i)
        };
      });

      this._formattedData = data;

      if (this._size) {
        var rExtent = extent(data, function (d) {
          return _this3._size(d.data);
        });

        this._sizeScaleD3 = function () {
          return _this3._sizeMin;
        };

        this._sizeScaleD3 = scales["scale".concat(this._sizeScale.charAt(0).toUpperCase()).concat(this._sizeScale.slice(1))]().domain(rExtent).range([rExtent[0] === rExtent[1] ? this._sizeMax : min([this._sizeMax / 2, this._sizeMin]), this._sizeMax]);
      } else {
        this._sizeScaleD3 = function () {
          return _this3._sizeMin;
        };
      }

      var x2Exists = data.some(function (d) {
        return d.x2 !== undefined;
      }),
          y2Exists = data.some(function (d) {
        return d.y2 !== undefined;
      });
      var height = this._height - this._margin.top - this._margin.bottom,
          opp = this._discrete ? this._discrete === "x" ? "y" : "x" : undefined,
          opp2 = this._discrete ? this._discrete === "x" ? "y2" : "x2" : undefined,
          opps = [opp, opp2].filter(function (d) {
        return d;
      }),
          parent = this._select,
          transition = this._transition,
          width = this._width - this._margin.left - this._margin.right;

      var x2Time = this._x2Time = this._time && data[0].x2 === this._time(data[0].data, data[0].i),
          xTime = this._xTime = this._time && data[0].x === this._time(data[0].data, data[0].i),
          y2Time = this._y2Time = this._time && data[0].y2 === this._time(data[0].data, data[0].i),
          yTime = this._yTime = this._time && data[0].y === this._time(data[0].data, data[0].i);

      for (var i = 0; i < data.length; i++) {
        var d = data[i];
        if (xTime) d.x = date(d.x);
        if (x2Time) d.x2 = date(d.x2);
        if (yTime) d.y = date(d.y);
        if (y2Time) d.y2 = date(d.y2);
        d.discrete = d.shape === "Bar" ? "".concat(d[this._discrete], "_").concat(d.group) : "".concat(d[this._discrete]);
      }
      /**
       * @desc Returns all unique values for a given axis.
       * @param {String} axis
       * @returns {Array}
       * @private
       */


      function getValues(axis) {
        var _this4 = this;

        var axisData = data.filter(function (d) {
          return d[axis];
        }).sort(function (a, b) {
          return _this4["_".concat(axis, "Sort")] ? _this4["_".concat(axis, "Sort")](a.data, b.data) : a[axis] - b[axis];
        }).map(function (d) {
          return d[axis];
        });

        if (this._discrete !== axis.charAt(0) && this._confidence) {
          if (this._confidence[0]) axisData = axisData.concat(data.map(function (d) {
            return d.lci;
          }));
          if (this._confidence[1]) axisData = axisData.concat(data.map(function (d) {
            return d.hci;
          }));
        }

        return unique(axisData, function (d) {
          return "".concat(d);
        });
      }

      var xData = getValues.bind(this)("x");
      var x2Data = getValues.bind(this)("x2");
      var yData = getValues.bind(this)("y");
      var y2Data = getValues.bind(this)("y2");
      var hasBars = data.some(function (d) {
        return d.shape === "Bar";
      });
      var discreteKeys, domains, stackData, stackKeys;

      if (this._stacked) {
        var _domains;

        var groupValues = nest().key(function (d) {
          return d.group;
        }).entries(data).reduce(function (obj, d) {
          if (!obj[d.key]) obj[d.key] = 0;
          obj[d.key] += sum(d.values, function (dd) {
            return dd[opp];
          });
          return obj;
        }, {});
        data = data.sort(function (a, b) {
          if (_this3["_".concat(_this3._discrete, "Sort")]) return _this3["_".concat(_this3._discrete, "Sort")](a.data, b.data);
          var a1 = a[_this3._discrete],
              b1 = b[_this3._discrete];
          if (a1 - b1 !== 0) return a1 - b1;
          if (a.group !== b.group) return groupValues[b.group] - groupValues[a.group];
          return b[opp] - a[opp];
        });
        discreteKeys = Array.from(new Set(data.map(function (d) {
          return d.discrete;
        })));
        stackKeys = Array.from(new Set(data.map(function (d) {
          return d.id;
        })));
        stackData = nest().key(function (d) {
          return d.discrete;
        }).entries(data).map(function (d) {
          return d.values;
        });
        stackData.forEach(function (g) {
          var ids = Array.from(new Set(g.map(function (d) {
            return d.id;
          })));

          if (ids.length < stackKeys.length) {
            stackKeys.forEach(function (k) {
              if (!ids.includes(k)) {
                var _d = data.filter(function (d) {
                  return d.id === k;
                })[0];

                if (_d.shape === "Area") {
                  var _fillerPoint;

                  var group = stackGroup(_d.data, _d.i);
                  var fillerPoint = (_fillerPoint = {
                    __d3plus__: true,
                    data: _d.data,
                    discrete: _d.shape === "Bar" ? "".concat(g[0][_this3._discrete], "_").concat(group) : "".concat(g[0][_this3._discrete]),
                    group: group,
                    id: k,
                    shape: _d.shape
                  }, _defineProperty(_fillerPoint, _this3._discrete, g[0][_this3._discrete]), _defineProperty(_fillerPoint, opp, 0), _fillerPoint);
                  data.push(fillerPoint);
                }
              }
            });
          }
        });

        if (this["_".concat(this._discrete, "Sort")]) {
          data.sort(function (a, b) {
            return _this3["_".concat(_this3._discrete, "Sort")](a.data, b.data);
          });
        } else {
          data.sort(function (a, b) {
            return a[_this3._discrete] - b[_this3._discrete];
          });
        }

        var order = this._stackOrder;
        if (order instanceof Array) stackKeys.sort(function (a, b) {
          return order.indexOf(a) - order.indexOf(b);
        });else if (order === d3Shape.stackOrderNone) stackKeys.sort(function (a, b) {
          return a.localeCompare(b);
        });
        stackData = d3Shape.stack().keys(stackKeys).offset(this._stackOffset).order(order instanceof Array ? d3Shape.stackOrderNone : order).value(function (group, key) {
          var d = group.filter(function (g) {
            return g.id === key;
          });
          return d.length ? d[0][opp] : 0;
        })(stackData);
        var discreteData = this._discrete === "x" ? xData : yData;
        domains = (_domains = {}, _defineProperty(_domains, this._discrete, !hasBars && this["_".concat(this._discrete, "Time")] ? extent(discreteData) : discreteData), _defineProperty(_domains, opp, [min(stackData.map(function (g) {
          return min(g.map(function (p) {
            return p[0];
          }));
        })), max(stackData.map(function (g) {
          return max(g.map(function (p) {
            return p[1];
          }));
        }))]), _domains);
      } else {
        var _discrete = this._discrete || "x";

        if (this["_".concat(this._discrete, "Sort")]) {
          data.sort(function (a, b) {
            return _this3["_".concat(_this3._discrete, "Sort")](a.data, b.data);
          });
        } else {
          data.sort(function (a, b) {
            return a[_discrete] - b[_discrete];
          });
        }

        domains = {
          x: (hasBars || !xTime) && this._discrete === "x" || this._xSort ? xData : extent(xData),
          x2: (hasBars || !x2Time) && this._discrete === "x" || this._x2Sort ? x2Data : extent(x2Data),
          y: (hasBars || !yTime) && this._discrete === "y" || this._ySort ? yData : extent(yData),
          y2: (hasBars || !y2Time) && this._discrete === "y" || this._y2Sort ? y2Data : extent(y2Data)
        };
      }
      /**
       * Determins default scale type and domain for a given axis.
       * @param {String} axis
       * @private
       */


      function domainScaleSetup(axis) {
        var domain = this["_".concat(axis, "Domain")] ? this["_".concat(axis, "Domain")].slice() : domains[axis],
            domain2 = this["_".concat(axis, "2Domain")] ? this["_".concat(axis, "2Domain")].slice() : domains["".concat(axis, "2")];
        if (domain && domain[0] === void 0) domain[0] = domains[axis][0];
        if (domain && domain[1] === void 0) domain[1] = domains[axis][1];
        if (domain2 && domain2[0] === void 0) domain2[0] = domains["".concat(axis, "2")][0];
        if (domain2 && domain2[1] === void 0) domain2[1] = domains["".concat(axis, "2")][1];
        var scale = !hasBars && this["_".concat(axis, "Time")] ? "Time" : this._discrete === axis || this["_".concat(axis, "Sort")] ? "Point" : "Linear";
        return [domain, scale, domain2, scale];
      }

      var _domainScaleSetup$bin = domainScaleSetup.bind(this)("x"),
          _domainScaleSetup$bin2 = _slicedToArray(_domainScaleSetup$bin, 4),
          xAutoDomain = _domainScaleSetup$bin2[0],
          xScale = _domainScaleSetup$bin2[1],
          x2AutoDomain = _domainScaleSetup$bin2[2],
          x2Scale = _domainScaleSetup$bin2[3];

      var _domainScaleSetup$bin3 = domainScaleSetup.bind(this)("y"),
          _domainScaleSetup$bin4 = _slicedToArray(_domainScaleSetup$bin3, 4),
          yAutoDomain = _domainScaleSetup$bin4[0],
          yScale = _domainScaleSetup$bin4[1],
          y2AutoDomain = _domainScaleSetup$bin4[2],
          y2Scale = _domainScaleSetup$bin4[3];

      var autoScale = function autoScale(axis, fallback) {
        var userScale = _this3["_".concat(axis, "Config")].scale;

        if (userScale === "auto") {
          if (_this3._discrete === axis) return fallback;
          var values = data.map(function (d) {
            return d[axis];
          });
          return deviation(values) / mean(values) > 3 ? "log" : "linear";
        }

        return userScale || fallback;
      };

      var yConfigScale = this._yConfigScale = autoScale("y", yScale).toLowerCase();
      var y2ConfigScale = this._y2ConfigScale = autoScale("y2", y2Scale).toLowerCase();
      var xConfigScale = this._xConfigScale = autoScale("x", xScale).toLowerCase();
      var x2ConfigScale = this._x2ConfigScale = autoScale("x2", x2Scale).toLowerCase();
      domains = {
        x: xAutoDomain,
        x2: x2AutoDomain || xAutoDomain,
        y: yAutoDomain,
        y2: y2AutoDomain || yAutoDomain
      };
      Object.keys(domains).forEach(function (axis) {
        if (_this3["_".concat(axis, "ConfigScale")] === "log" && domains[axis].includes(0)) {
          if (min(domains[axis]) < 0) domains[axis][1] = max(data.map(function (d) {
            return d[axis];
          }).filter(Boolean));else domains[axis][0] = min(data.map(function (d) {
            return d[axis];
          }).filter(Boolean));
        }
      });
      opps.forEach(function (opp) {
        if (_this3["_".concat(opp, "Config")].domain) {
          var _d2 = _this3["_".concat(opp, "Config")].domain;

          if (_this3._discrete === "x") _d2.reverse();
          domains[opp] = _d2;
        } else if (opp && _this3._baseline !== void 0) {
          var b = _this3._baseline;
          if (domains[opp] && domains[opp][0] > b) domains[opp][0] = b;else if (domains[opp] && domains[opp][1] < b) domains[opp][1] = b;
        }
      });

      var _x2 = scales["scale".concat(xScale)]().domain(domains.x).range(range(0, width + 1, width / (domains.x.length - 1))),
          x2 = scales["scale".concat(x2Scale)]().domain(domains.x2).range(range(0, width + 1, width / (domains.x2.length - 1))),
          _y2 = scales["scale".concat(yScale)]().domain(domains.y.reverse()).range(range(0, height + 1, height / (domains.y.length - 1))),
          y2 = scales["scale".concat(y2Scale)]().domain(domains.y2.reverse()).range(range(0, height + 1, height / (domains.y2.length - 1)));

      var shapeData = nest().key(function (d) {
        return d.shape;
      }).entries(data).sort(function (a, b) {
        return _this3._shapeSort(a.key, b.key);
      });
      var oppScale = this._discrete === "x" ? yScale : xScale;

      if (oppScale !== "Point") {
        shapeData.forEach(function (d) {
          if (_this3._buffer[d.key]) {
            var res = _this3._buffer[d.key].bind(_this3)({
              data: d.values,
              x: _x2,
              y: _y2,
              yScale: yConfigScale,
              xScale: xConfigScale,
              config: _this3._shapeConfig[d.key]
            });

            _x2 = res[0];
            _y2 = res[1];

            var res2 = _this3._buffer[d.key].bind(_this3)({
              data: d.values,
              x: x2,
              y: y2,
              yScale: y2ConfigScale,
              xScale: x2ConfigScale,
              x2: true,
              y2: true,
              config: _this3._shapeConfig[d.key]
            });

            x2 = res2[0];
            y2 = res2[1];
          }
        });
      }

      var xDomain = _x2.domain();

      var x2Domain = x2.domain();

      var yDomain = _y2.domain();

      var y2Domain = y2.domain();
      var defaultConfig = {
        barConfig: {
          "stroke-width": 0
        },
        gridSize: 0,
        labels: [],
        title: false,
        tickSize: 0
      };
      var defaultX2Config = x2Exists ? {
        data: x2Data
      } : defaultConfig;
      var defaultY2Config = y2Exists ? {
        data: y2Data
      } : defaultConfig;
      var showX = this._discrete === "x" && this._width > this._discreteCutoff || this._width > this._xCutoff;
      var showY = this._discrete === "y" && this._height > this._discreteCutoff || this._height > this._yCutoff;
      var yC = {
        data: yData,
        locale: this._locale,
        scalePadding: _y2.padding ? _y2.padding() : 0,
        tickFormat: yTime ? function (d) {
          return formatDate(+d, yData.map(Number));
        } : RESET
      };

      if (!showX) {
        yC.barConfig = {
          stroke: "transparent"
        };
        yC.tickSize = 0;
        yC.shapeConfig = {
          labelBounds: function labelBounds(d, i) {
            var _d$labelBounds = d.labelBounds,
                width = _d$labelBounds.width,
                y = _d$labelBounds.y;
            var height = _this3._height / 2;
            var x = i ? -height : 0;
            return {
              x: x,
              y: y,
              width: width,
              height: height
            };
          },
          labelConfig: {
            padding: 0,
            rotate: 0,
            verticalAlign: function verticalAlign(d) {
              return d.id === yTicks[0] ? "top" : "bottom";
            }
          },
          labelRotation: false
        };
      }

      var testGroup = elem("g.d3plus-plot-test", {
        enter: {
          opacity: 0
        },
        parent: this._select
      });
      var x2Ticks = this._discrete === "x" ? domains.x2 : undefined,
          xTicks = !showY ? extent(domains.x) : this._discrete === "x" ? domains.x : undefined,
          y2Ticks = this._discrete === "y" ? domains.y2 : undefined,
          yTicks = !showX ? extent(domains.y) : this._discrete === "y" ? domains.y : undefined;
      /**
       * Hides an axis' ticks and labels if they all exist as labels for the data to be displayed,
       * primarily occuring in simple BarChart visualizations where the both the x-axis ticks and
       * the Bar rectangles would be displaying the same text.
       */
      // generates an Array of String labels using the current label function for Bar shapes

      var barConfig = configPrep.bind(this)(this._shapeConfig, "shape", "Bar");
      var barLabelFunction = barConfig.label !== undefined ? typeof barConfig.label === "function" ? barConfig.label : constant(barConfig.label) : this._drawLabel;

      var barLabels = this._filteredData.map(function (d, i) {
        return barLabelFunction(d, i);
      }).filter(function (d) {
        return typeof d === "number" || d;
      }).map(String); // sets an axis' ticks to [] if the axis scale is "Point" (discrete) and every tick String
      // is also in the barLabels Array


      if (x2Scale === "Point" && x2Ticks instanceof Array && x2Ticks.every(function (t) {
        return barLabels.includes("".concat(t));
      })) x2Ticks = [];
      if (xScale === "Point" && xTicks instanceof Array && xTicks.every(function (t) {
        return barLabels.includes("".concat(t));
      })) xTicks = [];
      if (y2Scale === "Point" && y2Ticks instanceof Array && y2Ticks.every(function (t) {
        return barLabels.includes("".concat(t));
      })) y2Ticks = [];
      if (yScale === "Point" && yTicks instanceof Array && yTicks.every(function (t) {
        return barLabels.includes("".concat(t));
      })) yTicks = [];

      if (showY) {
        this._yTest.domain(yDomain).height(height).maxSize(width / 2).range([undefined, undefined]).select(testGroup.node()).ticks(yTicks).width(width).config(yC).config(this._yConfig).scale(yConfigScale).render();
      }

      var yBounds = this._yTest.outerBounds();

      var yWidth = yBounds.width ? yBounds.width + this._yTest.padding() : undefined;

      if (y2Exists) {
        this._y2Test.domain(y2Domain).height(height).range([undefined, undefined]).select(testGroup.node()).ticks(y2Ticks).width(width).config(yC).config(defaultY2Config).config(this._y2Config).scale(y2ConfigScale).render();
      }

      var y2Bounds = this._y2Test.outerBounds();

      var y2Width = y2Bounds.width ? y2Bounds.width + this._y2Test.padding() : undefined;
      var xC = {
        data: xData,
        locale: this._locale,
        scalePadding: _x2.padding ? _x2.padding() : 0,
        tickFormat: xTime ? function (d) {
          return formatDate(+d, xData.map(Number));
        } : RESET
      };

      if (!showY) {
        xC.barConfig = {
          stroke: "transparent"
        };
        xC.tickSize = 0;
        xC.shapeConfig = {
          labelBounds: function labelBounds(d, i) {
            var _d$labelBounds2 = d.labelBounds,
                height = _d$labelBounds2.height,
                y = _d$labelBounds2.y;
            var width = _this3._width / 2;
            var x = i ? -width : 0;
            return {
              x: x,
              y: y,
              width: width,
              height: height
            };
          },
          labelConfig: {
            padding: 0,
            rotate: 0,
            textAnchor: function textAnchor(d) {
              return d.id === xTicks[0] ? "start" : "end";
            }
          },
          labelRotation: false
        };
      }

      var xRangeMax = undefined;

      if (showX) {
        this._xTest.domain(xDomain).height(height).maxSize(height / 2).range([undefined, xRangeMax]).select(testGroup.node()).ticks(xTicks).width(width).config(xC).config(this._xConfig).scale(xConfigScale).render();
      }

      var largestLabel;

      if (this._lineLabels) {
        var lineData = nest().key(function (d) {
          return d.id;
        }).entries(data.filter(function (d) {
          return d.shape === "Line";
        }));

        if (lineData.length && lineData.length < this._dataCutoff) {
          var userConfig = configPrep.bind(this)(this._shapeConfig, "shape", "Line");
          testLineShape.config(userConfig);
          var lineLabelConfig = testLineShape.labelConfig();
          var fontSizeAccessor = lineLabelConfig.fontSize !== undefined ? lineLabelConfig.fontSize : testTextBox.fontSize();
          var fontWeightAccessor = lineLabelConfig.fontWeight !== undefined ? lineLabelConfig.fontWeight : testTextBox.fontWeight();
          var fontFamilyAccessor = lineLabelConfig.fontFamily !== undefined ? lineLabelConfig.fontFamily : testTextBox.fontFamily();
          var paddingAccessor = lineLabelConfig.padding !== undefined ? lineLabelConfig.padding : testTextBox.padding();
          var labelFunction = userConfig.label || this._drawLabel;

          var xEstimate = function xEstimate(d) {
            if (xConfigScale === "log" && d === 0) d = xDomain[0] < 0 ? _this3._xTest._d3Scale.domain()[1] : _this3._xTest._d3Scale.domain()[0];
            return _this3._xTest._getPosition.bind(_this3._xTest)(d);
          };

          var maxX = max(lineData.map(function (group) {
            return max(group.values.map(function (d) {
              return xEstimate(d.x);
            }));
          }));
          var labelWidths = lineData.map(function (group) {
            var d = group.values[group.values.length - 1];
            var i;

            while (d.__d3plus__ && d.data) {
              d = d.data;
              i = d.i;
            }

            var label = typeof labelFunction === "function" ? labelFunction(d, i) : labelFunction;
            var fontSize = typeof fontSizeAccessor === "function" ? fontSizeAccessor(d, i) : fontSizeAccessor;
            var fontWeight = typeof fontWeightAccessor === "function" ? fontWeightAccessor(d, i) : fontWeightAccessor;
            var fontFamily = typeof fontFamilyAccessor === "function" ? fontFamilyAccessor(d, i) : fontFamilyAccessor;
            if (fontFamily instanceof Array) fontFamily = fontFamily.map(function (f) {
              return "'".concat(f, "'");
            }).join(", ");
            var labelPadding = typeof paddingAccessor === "function" ? paddingAccessor(d, i) : paddingAccessor;
            var labelWidth = textWidth(label, {
              "font-size": fontSize,
              "font-family": fontFamily,
              "font-weight": fontWeight
            });
            var myMaxX = max(group.values.map(function (d) {
              return xEstimate(d.x);
            }));
            return {
              labelWidth: labelWidth + labelPadding * 2,
              spaceNeeded: myMaxX - maxX + labelWidth + labelPadding * 2
            };
          });
          largestLabel = max(labelWidths.map(function (d) {
            return d.labelWidth;
          }));
          var spaceNeeded = max(labelWidths.map(function (d) {
            return d.spaceNeeded;
          }));
          var labelSpace = min([spaceNeeded, width / 4]);
          xRangeMax = width - labelSpace - this._margin.right;
        }
      }

      if (showX && xRangeMax) {
        this._xTest.domain(xDomain).height(height).maxSize(height / 2).range([undefined, xRangeMax]).select(testGroup.node()).ticks(xTicks).width(width).config(xC).config(this._xConfig).scale(xConfigScale).render();
      }

      if (x2Exists) {
        this._x2Test.domain(x2Domain).height(height).range([undefined, xRangeMax]).select(testGroup.node()).ticks(x2Ticks).width(width).config(xC).tickSize(0).config(defaultX2Config).config(this._x2Config).scale(x2ConfigScale).render();
      }

      var xTestRange = this._xTest._getRange();

      var x2TestRange = this._x2Test._getRange();

      var x2Bounds = this._x2Test.outerBounds();

      var x2Height = x2Exists ? x2Bounds.height + this._x2Test.padding() : 0;
      var xOffsetLeft = max([yWidth, xTestRange[0], x2TestRange[0]]);

      if (showX) {
        this._xTest.range([xOffsetLeft, undefined]).render();
      }

      var topOffset = showY ? this._yTest.shapeConfig().labelConfig.fontSize() / 2 : 0;
      var xOffsetRight = max([y2Width, width - xTestRange[1], width - x2TestRange[1]]);

      var xBounds = this._xTest.outerBounds();

      var xHeight = xBounds.height + (showY ? this._xTest.padding() : 0);
      this._padding.left += xOffsetLeft;
      this._padding.right += xOffsetRight;
      this._padding.bottom += xHeight;
      this._padding.top += x2Height + topOffset;

      _get(_getPrototypeOf(Plot.prototype), "_draw", this).call(this, callback);

      var horizontalMargin = this._margin.left + this._margin.right;
      var verticalMargin = this._margin.top + this._margin.bottom;
      var yRange = [x2Height, height - (xHeight + topOffset + verticalMargin)];

      if (showY) {
        this._yTest.domain(yDomain).height(height).maxSize(width / 2).range(yRange).select(testGroup.node()).ticks(yTicks).width(width).config(yC).config(this._yConfig).scale(yConfigScale).render();
      }

      yBounds = this._yTest.outerBounds();
      yWidth = yBounds.width ? yBounds.width + this._yTest.padding() : undefined;
      xOffsetLeft = max([yWidth, xTestRange[0], x2TestRange[0]]);

      if (y2Exists) {
        this._y2Test.config(yC).domain(y2Domain).gridSize(0).height(height).range(yRange).select(testGroup.node()).width(width - max([0, xOffsetRight - y2Width])).title(false).config(this._y2Config).config(defaultY2Config).scale(y2ConfigScale).render();
      }

      y2Bounds = this._y2Test.outerBounds();
      y2Width = y2Bounds.width ? y2Bounds.width + this._y2Test.padding() : undefined;
      xOffsetRight = max([0, y2Width, width - xTestRange[1], width - x2TestRange[1]]);
      var xRange = [xOffsetLeft, width - (xOffsetRight + horizontalMargin)];
      var rectGroup = elem("g.d3plus-plot-background", {
        parent: parent,
        transition: transition
      });
      var transform = "translate(".concat(this._margin.left, ", ").concat(this._margin.top + x2Height + topOffset, ")");
      var x2Transform = "translate(".concat(this._margin.left, ", ").concat(this._margin.top + topOffset, ")");
      var xGroup = showX && elem("g.d3plus-plot-x-axis", {
        parent: parent,
        transition: transition,
        enter: {
          transform: transform
        },
        update: {
          transform: transform
        }
      });
      var x2Group = x2Exists && elem("g.d3plus-plot-x2-axis", {
        parent: parent,
        transition: transition,
        enter: {
          transform: x2Transform
        },
        update: {
          transform: x2Transform
        }
      });
      var xTrans = xOffsetLeft > yWidth ? xOffsetLeft - yWidth : 0;
      var yTransform = "translate(".concat(this._margin.left + xTrans, ", ").concat(this._margin.top + topOffset, ")");
      var yGroup = showY && elem("g.d3plus-plot-y-axis", {
        parent: parent,
        transition: transition,
        enter: {
          transform: yTransform
        },
        update: {
          transform: yTransform
        }
      });
      var y2Transform = "translate(-".concat(this._margin.right, ", ").concat(this._margin.top + topOffset, ")");
      var y2Group = y2Exists && elem("g.d3plus-plot-y2-axis", {
        parent: parent,
        transition: transition,
        enter: {
          transform: y2Transform
        },
        update: {
          transform: y2Transform
        }
      });

      this._xAxis.domain(xDomain).height(height - (x2Height + topOffset + verticalMargin)).maxSize(height / 2).range(xRange).select(showX ? xGroup.node() : undefined).ticks(xTicks).width(width).config(xC).config(this._xConfig).scale(xConfigScale).render();

      if (x2Exists) {
        this._x2Axis.domain(x2Domain).height(height - (xHeight + topOffset + verticalMargin)).range(xRange).select(x2Group.node()).ticks(x2Ticks).width(width).config(xC).config(defaultX2Config).config(this._x2Config).scale(x2ConfigScale).render();
      }

      this._xFunc = _x2 = function x(d, _x) {
        if (_x === "x2") {
          if (x2ConfigScale === "log" && d === 0) d = x2Domain[0] < 0 ? _this3._x2Axis._d3Scale.domain()[1] : _this3._x2Axis._d3Scale.domain()[0];
          return _this3._x2Axis._getPosition.bind(_this3._x2Axis)(d);
        } else {
          if (xConfigScale === "log" && d === 0) d = xDomain[0] < 0 ? _this3._xAxis._d3Scale.domain()[1] : _this3._xAxis._d3Scale.domain()[0];
          return _this3._xAxis._getPosition.bind(_this3._xAxis)(d);
        }
      };

      yRange = [this._xAxis.outerBounds().y + x2Height, height - (xHeight + topOffset + verticalMargin)];

      this._yAxis.domain(yDomain).height(height).maxSize(width / 2).range(yRange).select(showY ? yGroup.node() : undefined).ticks(yTicks).width(xRange[xRange.length - 1]).config(yC).config(this._yConfig).scale(yConfigScale).render();

      if (y2Exists) {
        this._y2Axis.config(yC).domain(y2Exists ? y2Domain : yDomain).gridSize(0).height(height).range(yRange).select(y2Group.node()).width(width - max([0, xOffsetRight - y2Width])).title(false).config(this._y2Config).config(defaultY2Config).scale(y2ConfigScale).render();
      }

      this._yFunc = _y2 = function y(d, _y) {
        if (_y === "y2") {
          if (y2ConfigScale === "log" && d === 0) d = y2Domain[1] < 0 ? _this3._y2Axis._d3ScaleNegative.domain()[0] : _this3._y2Axis._d3Scale.domain()[1];
          return _this3._y2Axis._getPosition.bind(_this3._y2Axis)(d) - x2Height;
        } else {
          if (yConfigScale === "log" && d === 0) d = yDomain[1] < 0 ? _this3._yAxis._d3ScaleNegative.domain()[0] : _this3._yAxis._d3Scale.domain()[1];
          return _this3._yAxis._getPosition.bind(_this3._yAxis)(d) - x2Height;
        }
      };

      new shapes.Rect().data([{}]).select(rectGroup.node()).x(xRange[0] + (xRange[1] - xRange[0]) / 2).width(xRange[1] - xRange[0]).y(this._margin.top + topOffset + yRange[0] + (yRange[1] - yRange[0]) / 2).height(yRange[1] - yRange[0]).config(this._backgroundConfig).render();
      var annotationGroup = elem("g.d3plus-plot-annotations", {
        parent: parent,
        transition: transition,
        enter: {
          transform: transform
        },
        update: {
          transform: transform
        }
      }).node();

      this._annotations.forEach(function (annotation) {
        new shapes[annotation.shape]().config(annotation).config({
          x: function x(d) {
            return d.x2 ? _x2(d.x2, "x2") : _x2(d.x);
          },
          x0: _this3._discrete === "x" ? function (d) {
            return d.x2 ? _x2(d.x2, "x2") : _x2(d.x);
          } : _x2(domains.x[0]),
          x1: _this3._discrete === "x" ? null : function (d) {
            return d.x2 ? _x2(d.x2, "x2") : _x2(d.x);
          },
          y: function y(d) {
            return d.y2 ? _y2(d.y2, "y2") : _y2(d.y);
          },
          y0: _this3._discrete === "y" ? function (d) {
            return d.y2 ? _y2(d.y2, "y2") : _y2(d.y);
          } : _y2(domains.y[1]) - yOffset,
          y1: _this3._discrete === "y" ? null : function (d) {
            return d.y2 ? _y2(d.y2, "y2") : _y2(d.y) - yOffset;
          }
        }).select(annotationGroup).render();
      });

      var yOffset = this._xAxis.barConfig()["stroke-width"];

      if (yOffset) yOffset /= 2;
      var discrete = this._discrete || "x";
      var shapeConfig = {
        discrete: this._discrete,
        duration: this._duration,
        label: function label(d) {
          return _this3._drawLabel(d.data, d.i);
        },
        select: elem("g.d3plus-plot-shapes", {
          parent: parent,
          transition: transition,
          enter: {
            transform: transform
          },
          update: {
            transform: transform
          }
        }).node(),
        x: function x(d) {
          return d.x2 !== undefined ? _x2(d.x2, "x2") : _x2(d.x);
        },
        x0: discrete === "x" ? function (d) {
          return d.x2 ? _x2(d.x2, "x2") : _x2(d.x);
        } : _x2(typeof this._baseline === "number" ? this._baseline : domains.x[0]),
        x1: discrete === "x" ? null : function (d) {
          return d.x2 ? _x2(d.x2, "x2") : _x2(d.x);
        },
        y: function y(d) {
          return d.y2 !== undefined ? _y2(d.y2, "y2") : _y2(d.y);
        },
        y0: discrete === "y" ? function (d) {
          return d.y2 ? _y2(d.y2, "y2") : _y2(d.y);
        } : _y2(typeof this._baseline === "number" ? this._baseline : domains.y[1]) - yOffset,
        y1: discrete === "y" ? null : function (d) {
          return d.y2 ? _y2(d.y2, "y2") : _y2(d.y) - yOffset;
        }
      };

      if (this._stacked) {
        var scale = opp === "x" ? _x2 : _y2;

        shapeConfig["".concat(opp)] = shapeConfig["".concat(opp, "0")] = function (d) {
          var dataIndex = stackKeys.indexOf(d.id),
              discreteIndex = discreteKeys.indexOf(d.discrete);
          return dataIndex >= 0 ? scale(stackData[dataIndex][discreteIndex][0]) : scale(domains[opp][opp === "x" ? 0 : 1]);
        };

        shapeConfig["".concat(opp, "1")] = function (d) {
          var dataIndex = stackKeys.indexOf(d.id),
              discreteIndex = discreteKeys.indexOf(d.discrete);
          return dataIndex >= 0 ? scale(stackData[dataIndex][discreteIndex][1]) : scale(domains[opp][opp === "x" ? 0 : 1]);
        };
      }

      var events = Object.keys(this._on);
      shapeData.forEach(function (d) {
        var s = new shapes[d.key]().config(shapeConfig).data(d.values);

        if (d.key === "Bar") {
          var space;

          var _scale = _this3._discrete === "x" ? _x2 : _y2;

          var scaleType = _this3._discrete === "x" ? xScale : yScale;
          var vals = _this3._discrete === "x" ? xDomain : yDomain;

          var _range = _this3._discrete === "x" ? xRange : yRange;

          if (scaleType !== "Point" && vals.length === 2) {
            space = (_scale(d.values[_this3._discrete === "x" ? 0 : d.values.length - 1][_this3._discrete]) - _scale(vals[0])) * 2;
          } else if (vals.length > 1) space = _scale(vals[1]) - _scale(vals[0]);else space = _range[_range.length - 1] - _range[0];

          if (_this3._groupPadding < space) space -= _this3._groupPadding;
          var barSize = space || 1;
          var groups = nest().key(function (d) {
            return d[_this3._discrete];
          }).key(function (d) {
            return d.group;
          }).entries(d.values);
          var ids = merge(groups.map(function (d) {
            return d.values.map(function (v) {
              return v.key;
            });
          }));
          var uniqueIds = Array.from(new Set(ids));

          if (max(groups.map(function (d) {
            return d.values.length;
          })) === 1) {
            s[_this3._discrete](function (d, i) {
              return shapeConfig[_this3._discrete](d, i);
            });
          } else {
            barSize = (barSize - _this3._barPadding * uniqueIds.length - 1) / uniqueIds.length;
            var offset = space / 2 - barSize / 2;
            var xMod = scales.scaleLinear().domain([0, uniqueIds.length - 1]).range([-offset, offset]);

            s[_this3._discrete](function (d, i) {
              return shapeConfig[_this3._discrete](d, i) + xMod(uniqueIds.indexOf(d.group));
            });
          }

          s.width(barSize);
          s.height(barSize);
        } else if (d.key === "Line") {
          s.duration(width * 1.5);

          if (_this3._confidence) {
            var areaConfig = Object.assign({}, shapeConfig);

            var _discrete2 = _this3._discrete || "x";

            var key = _discrete2 === "x" ? "y" : "x";
            var scaleFunction = _discrete2 === "x" ? _y2 : _x2;

            areaConfig["".concat(key, "0")] = function (d) {
              return scaleFunction(_this3._confidence[0] ? d.lci : d[key]);
            };

            areaConfig["".concat(key, "1")] = function (d) {
              return scaleFunction(_this3._confidence[1] ? d.hci : d[key]);
            };

            var area = new shapes.Area().config(areaConfig).data(d.values);
            var confidenceConfig = Object.assign(_this3._shapeConfig, _this3._confidenceConfig);
            area.config(assign(configPrep.bind(_this3)(confidenceConfig, "shape", "Line"), configPrep.bind(_this3)(confidenceConfig, "shape", "Area"))).render();

            _this3._shapes.push(area);
          }

          s.config({
            discrete: shapeConfig.discrete || "x",
            label: _this3._lineLabels ? _this3._drawLabel : false,
            labelBounds: _this3._lineLabels ? function (d, i, s) {
              var _s$points$ = _slicedToArray(s.points[0], 2),
                  firstX = _s$points$[0],
                  firstY = _s$points$[1];

              var _s$points = _slicedToArray(s.points[s.points.length - 1], 2),
                  lastX = _s$points[0],
                  lastY = _s$points[1];

              var height = _this3._height / 4;
              return {
                x: lastX - firstX,
                y: lastY - firstY - height / 2,
                width: largestLabel,
                height: height
              };
            } : false
          });
        }

        var classEvents = events.filter(function (e) {
          return e.includes(".".concat(d.key));
        }),
            globalEvents = events.filter(function (e) {
          return !e.includes(".");
        }),
            shapeEvents = events.filter(function (e) {
          return e.includes(".shape");
        });

        var _loop = function _loop(e) {
          s.on(globalEvents[e], function (d, i, x, event) {
            return _this3._on[globalEvents[e]](d.data, d.i, x, event);
          });
        };

        for (var e = 0; e < globalEvents.length; e++) {
          _loop(e);
        }

        var _loop2 = function _loop2(_e2) {
          s.on(shapeEvents[_e2], function (d, i, x, event) {
            return _this3._on[shapeEvents[_e2]](d.data, d.i, x, event);
          });
        };

        for (var _e2 = 0; _e2 < shapeEvents.length; _e2++) {
          _loop2(_e2);
        }

        var _loop3 = function _loop3(_e3) {
          s.on(classEvents[_e3], function (d, i, x, event) {
            return _this3._on[classEvents[_e3]](d.data, d.i, x, event);
          });
        };

        for (var _e3 = 0; _e3 < classEvents.length; _e3++) {
          _loop3(_e3);
        }

        var userConfig = configPrep.bind(_this3)(_this3._shapeConfig, "shape", d.key);
        if (_this3._shapeConfig.duration === undefined) delete userConfig.duration;
        s.config(userConfig).render();

        _this3._shapes.push(s);

        if (d.key === "Line" && _this3._lineMarkers) {
          var markers = new shapes.Circle().data(d.values).config(shapeConfig).config(_this3._lineMarkerConfig).id(function (d) {
            return "".concat(d.id, "_").concat(d.discrete);
          });

          var _loop4 = function _loop4(_e4) {
            markers.on(globalEvents[_e4], function (d, i, x, event) {
              return _this3._on[globalEvents[_e4]](d.data, d.i, x, event);
            });
          };

          for (var _e4 = 0; _e4 < globalEvents.length; _e4++) {
            _loop4(_e4);
          }

          var _loop5 = function _loop5(_e5) {
            markers.on(shapeEvents[_e5], function (d, i, x, event) {
              return _this3._on[shapeEvents[_e5]](d.data, d.i, x, event);
            });
          };

          for (var _e5 = 0; _e5 < shapeEvents.length; _e5++) {
            _loop5(_e5);
          }

          var _loop6 = function _loop6(_e6) {
            markers.on(classEvents[_e6], function (d, i, x, event) {
              return _this3._on[classEvents[_e6]](d.data, d.i, x, event);
            });
          };

          for (var _e6 = 0; _e6 < classEvents.length; _e6++) {
            _loop6(_e6);
          }

          markers.render();

          _this3._shapes.push(markers);
        }
      });
      var dataShapes = shapeData.map(function (d) {
        return d.key;
      });

      if (dataShapes.includes("Line")) {
        if (this._confidence) dataShapes.push("Area");
        if (this._labelMarkers) dataShapes.push("Circle");
      }

      var exitShapes = this._previousShapes.filter(function (d) {
        return !dataShapes.includes(d);
      });

      exitShapes.forEach(function (shape) {
        new shapes[shape]().config(shapeConfig).data([]).render();
      });
      this._previousShapes = dataShapes;
      return this;
    }
    /**
        @memberof Plot
        @desc Allows drawing custom shapes to be used as annotations in the provided x/y plot. This method accepts custom config objects for the [Shape](http://d3plus.org/docs/#Shape) class, either a single config object or an array of config objects. Each config object requires an additional parameter, the "shape", which denotes which [Shape](http://d3plus.org/docs/#Shape) sub-class to use ([Rect](http://d3plus.org/docs/#Rect), [Line](http://d3plus.org/docs/#Line), etc). Annotations will be drawn underneath the data to be displayed.
        @param {Array|Object} *annotations* = []
        @chainable
    */

  }, {
    key: "annotations",
    value: function annotations(_) {
      return arguments.length ? (this._annotations = _ instanceof Array ? _ : [_], this) : this._annotations;
    }
    /**
         @memberof Plot
         @desc A d3plus-shape configuration Object used for styling the background rectangle of the inner x/y plot (behind all of the shapes and gridlines).
         @param {Object} [*value*]
         @chainable
     */

  }, {
    key: "backgroundConfig",
    value: function backgroundConfig(_) {
      return arguments.length ? (this._backgroundConfig = assign(this._backgroundConfig, _), this) : this._backgroundConfig;
    }
    /**
        @memberof Plot
        @desc Sets the pixel space between each bar in a group of bars.
        @param {Number} *value* = 0
        @chainable
    */

  }, {
    key: "barPadding",
    value: function barPadding(_) {
      return arguments.length ? (this._barPadding = _, this) : this._barPadding;
    }
    /**
        @memberof Plot
        @desc Sets the baseline for the x/y plot. If *value* is not specified, returns the current baseline.
        @param {Number} *value*
        @chainable
    */

  }, {
    key: "baseline",
    value: function baseline(_) {
      return arguments.length ? (this._baseline = _, this) : this._baseline;
    }
    /**
         @memberof Plot
         @desc Sets the confidence to the specified array of lower and upper bounds.
         @param {String[]|Function[]} *value*
         @chainable
         @example <caption>Can be called with accessor functions or static keys:</caption>
         var data = {id: "alpha", value: 10, lci: 9, hci: 11};
         ...
         // Accessor functions
         .confidence([function(d) { return d.lci }, function(d) { return d.hci }])
          // Or static keys
         .confidence(["lci", "hci"])
     */

  }, {
    key: "confidence",
    value: function confidence(_) {
      if (arguments.length && _ instanceof Array) {
        this._confidence = [];
        var lower = _[0];
        this._confidence[0] = typeof lower === "function" || !lower ? lower : accessor(lower);
        var upper = _[1];
        this._confidence[1] = typeof upper === "function" || !upper ? upper : accessor(upper);
        return this;
      } else return this._confidence;
    }
    /**
         @memberof Plot
         @desc If *value* is specified, sets the config method for each shape rendered as a confidence interval and returns the current class instance.
         @param {Object} [*value*]
         @chainable
     */

  }, {
    key: "confidenceConfig",
    value: function confidenceConfig(_) {
      return arguments.length ? (this._confidenceConfig = assign(this._confidenceConfig, _), this) : this._confidenceConfig;
    }
    /**
        @memberof Plot
        @desc Sets the discrete axis to the specified string. If *value* is not specified, returns the current discrete axis.
        @param {String} *value*
        @chainable
    */

  }, {
    key: "discrete",
    value: function discrete(_) {
      return arguments.length ? (this._discrete = _, this) : this._discrete;
    }
    /**
        @memberof Plot
        @desc When the width or height of the chart is less than or equal to this pixel value, the discrete axis will not be shown. This helps produce slick sparklines. Set this value to `0` to disable the behavior entirely.
        @param {Number} *value*
        @chainable
    */

  }, {
    key: "discreteCutoff",
    value: function discreteCutoff(_) {
      return arguments.length ? (this._discreteCutoff = _, this) : this._discreteCutoff;
    }
    /**
        @memberof Plot
        @desc Sets the pixel space between groups of bars.
        @param {Number} [*value* = 5]
        @chainable
    */

  }, {
    key: "groupPadding",
    value: function groupPadding(_) {
      return arguments.length ? (this._groupPadding = _, this) : this._groupPadding;
    }
    /**
        @memberof Plot
        @desc Draws labels on the right side of any Line shapes that are drawn on the plot.
        @param {Boolean} [*value* = false]
        @chainable
    */

  }, {
    key: "lineLabels",
    value: function lineLabels(_) {
      return arguments.length ? (this._lineLabels = _, this) : this._lineLabels;
    }
    /**
        @memberof Plot
        @desc Shape config for the Circle shapes drawn by the lineMarkers method.
        @param {Object} *value*
        @chainable
    */

  }, {
    key: "lineMarkerConfig",
    value: function lineMarkerConfig(_) {
      return arguments.length ? (this._lineMarkerConfig = assign(this._lineMarkerConfig, _), this) : this._lineMarkerConfig;
    }
    /**
        @memberof Plot
        @desc Draws circle markers on each vertex of a Line.
        @param {Boolean} [*value* = false]
        @chainable
    */

  }, {
    key: "lineMarkers",
    value: function lineMarkers(_) {
      return arguments.length ? (this._lineMarkers = _, this) : this._lineMarkers;
    }
    /**
        @memberof Plot
        @desc A JavaScript [sort comparator function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) that receives each shape Class (ie. "Circle", "Line", etc) as it's comparator arguments. Shapes are drawn in groups based on their type, so you are defining the layering order for all shapes of said type.
        @param {Function} *value*
        @chainable
    */

  }, {
    key: "shapeSort",
    value: function shapeSort(_) {
      return arguments.length ? (this._shapeSort = _, this) : this._shapeSort;
    }
    /**
        @memberof Plot
        @desc Sets the size of bubbles to the given Number, data key, or function.
        @param {Function|Number|String} *value* = 10
        @chainable
    */

  }, {
    key: "size",
    value: function size(_) {
      return arguments.length ? (this._size = typeof _ === "function" || !_ ? _ : accessor(_), this) : this._size;
    }
    /**
        @memberof Plot
        @desc Sets the size scale maximum to the specified number.
        @param {Number} *value* = 20
        @chainable
    */

  }, {
    key: "sizeMax",
    value: function sizeMax(_) {
      return arguments.length ? (this._sizeMax = _, this) : this._sizeMax;
    }
    /**
        @memberof Plot
        @desc Sets the size scale minimum to the specified number.
        @param {Number} *value* = 5
        @chainable
    */

  }, {
    key: "sizeMin",
    value: function sizeMin(_) {
      return arguments.length ? (this._sizeMin = _, this) : this._sizeMin;
    }
    /**
        @memberof Plot
        @desc Sets the size scale to the specified string.
        @param {String} *value* = "sqrt"
        @chainable
    */

  }, {
    key: "sizeScale",
    value: function sizeScale(_) {
      return arguments.length ? (this._sizeScale = _, this) : this._sizeScale;
    }
    /**
        @memberof Plot
        @desc If *value* is specified, toggles shape stacking. If *value* is not specified, returns the current stack value.
        @param {Boolean} *value* = false
        @chainable
    */

  }, {
    key: "stacked",
    value: function stacked(_) {
      return arguments.length ? (this._stacked = _, this) : this._stacked;
    }
    /**
        @memberof Plot
        @desc Sets the stack offset. If *value* is not specified, returns the current stack offset function.
        @param {Function|String} *value* = "descending"
        @chainable
    */

  }, {
    key: "stackOffset",
    value: function stackOffset(_) {
      return arguments.length ? (this._stackOffset = typeof _ === "function" ? _ : d3Shape["stackOffset".concat(_.charAt(0).toUpperCase() + _.slice(1))], this) : this._stackOffset;
    }
    /**
        @memberof Plot
        @desc Sets the stack order. If *value* is not specified, returns the current stack order function.
        @param {Function|String|Array} *value* = "none"
        @chainable
    */

  }, {
    key: "stackOrder",
    value: function stackOrder(_) {
      if (arguments.length) {
        if (typeof _ === "string") this._stackOrder = _ === "ascending" ? stackOrderAscending : _ === "descending" ? stackOrderDescending : d3Shape["stackOrder".concat(_.charAt(0).toUpperCase() + _.slice(1))];else this._stackOrder = _;
        return this;
      } else return this._stackOrder;
    }
    /**
        @memberof Plot
        @desc Sets the x accessor to the specified function or number. If *value* is not specified, returns the current x accessor.
        @param {Function|Number} *value*
        @chainable
    */

  }, {
    key: "x",
    value: function x(_) {
      if (arguments.length) {
        if (typeof _ === "function") this._x = _;else {
          this._x = accessor(_);
          this._xKey = _;
        }
        return this;
      } else return this._x;
    }
    /**
         @memberof Plot
         @desc Sets the x2 accessor to the specified function or number. If *value* is not specified, returns the current x2 accessor.
         @param {Function|Number} *value*
         @chainable
     */

  }, {
    key: "x2",
    value: function x2(_) {
      if (arguments.length) {
        if (typeof _ === "function") this._x2 = _;else {
          this._x2 = accessor(_);
          this._x2Key = _;
        }
        return this;
      } else return this._x2;
    }
    /**
        @memberof Plot
        @desc A pass-through to the underlying [Axis](http://d3plus.org/docs/#Axis) config used for the x-axis. Includes additional functionality where passing "auto" as the value for the [scale](http://d3plus.org/docs/#Axis.scale) method will determine if the scale should be "linear" or "log" based on the provided data.
        @param {Object} *value*
        @chainable
    */

  }, {
    key: "xConfig",
    value: function xConfig(_) {
      return arguments.length ? (this._xConfig = assign(this._xConfig, _), this) : this._xConfig;
    }
    /**
        @memberof Plot
        @desc When the width of the chart is less than or equal to this pixel value, and the x-axis is not the discrete axis, it will not be shown. This helps produce slick sparklines. Set this value to `0` to disable the behavior entirely.
        @param {Number} *value*
        @chainable
    */

  }, {
    key: "xCutoff",
    value: function xCutoff(_) {
      return arguments.length ? (this._xCutoff = _, this) : this._xCutoff;
    }
    /**
        @memberof Plot
        @desc A pass-through to the underlying [Axis](http://d3plus.org/docs/#Axis) config used for the secondary x-axis. Includes additional functionality where passing "auto" as the value for the [scale](http://d3plus.org/docs/#Axis.scale) method will determine if the scale should be "linear" or "log" based on the provided data.
        @param {Object} *value*
        @chainable
    */

  }, {
    key: "x2Config",
    value: function x2Config(_) {
      return arguments.length ? (this._x2Config = assign(this._x2Config, _), this) : this._x2Config;
    }
    /**
        @memberof Plot
        @desc Sets the x domain to the specified array. If *value* is not specified, returns the current x domain. Additionally, if either value of the array is undefined, it will be calculated from the data.
        @param {Array} *value*
        @chainable
    */

  }, {
    key: "xDomain",
    value: function xDomain(_) {
      return arguments.length ? (this._xDomain = _, this) : this._xDomain;
    }
    /**
         @memberof Plot
         @desc Sets the x2 domain to the specified array. If *value* is not specified, returns the current x2 domain. Additionally, if either value of the array is undefined, it will be calculated from the data.
         @param {Array} *value*
         @chainable
     */

  }, {
    key: "x2Domain",
    value: function x2Domain(_) {
      return arguments.length ? (this._x2Domain = _, this) : this._x2Domain;
    }
    /**
        @memberof Plot
        @desc Defines a custom sorting comparitor function to be used for discrete x axes.
        @param {Function} *value*
        @chainable
    */

  }, {
    key: "xSort",
    value: function xSort(_) {
      return arguments.length ? (this._xSort = _, this) : this._xSort;
    }
    /**
         @memberof Plot
         @desc Defines a custom sorting comparitor function to be used for discrete x2 axes.
         @param {Function} *value*
         @chainable
     */

  }, {
    key: "x2Sort",
    value: function x2Sort(_) {
      return arguments.length ? (this._x2Sort = _, this) : this._x2Sort;
    }
    /**
        @memberof Plot
        @desc Sets the y accessor to the specified function or number. If *value* is not specified, returns the current y accessor.
        @param {Function|Number} *value*
        @chainable
    */

  }, {
    key: "y",
    value: function y(_) {
      if (arguments.length) {
        if (typeof _ === "function") this._y = _;else {
          this._y = accessor(_);
          this._yKey = _;
        }
        return this;
      } else return this._y;
    }
    /**
         @memberof Plot
         @desc Sets the y2 accessor to the specified function or number. If *value* is not specified, returns the current y2 accessor.
         @param {Function|Number} *value*
         @chainable
     */

  }, {
    key: "y2",
    value: function y2(_) {
      if (arguments.length) {
        if (typeof _ === "function") this._y2 = _;else {
          this._y2 = accessor(_);
          this._y2Key = _;
        }
        return this;
      } else return this._y2;
    }
    /**
        @memberof Plot
        @desc A pass-through to the underlying [Axis](http://d3plus.org/docs/#Axis) config used for the y-axis. Includes additional functionality where passing "auto" as the value for the [scale](http://d3plus.org/docs/#Axis.scale) method will determine if the scale should be "linear" or "log" based on the provided data.
    *Note:* If a "domain" array is passed to the y-axis config, it will be reversed.
        @param {Object} *value*
        @chainable
    */

  }, {
    key: "yConfig",
    value: function yConfig(_) {
      if (arguments.length) {
        if (_.domain) _.domain = _.domain.slice().reverse();
        this._yConfig = assign(this._yConfig, _);
        return this;
      }

      return this._yConfig;
    }
    /**
        @memberof Plot
        @desc When the height of the chart is less than or equal to this pixel value, and the y-axis is not the discrete axis, it will not be shown. This helps produce slick sparklines. Set this value to `0` to disable the behavior entirely.
        @param {Number} *value*
        @chainable
    */

  }, {
    key: "yCutoff",
    value: function yCutoff(_) {
      return arguments.length ? (this._yCutoff = _, this) : this._yCutoff;
    }
    /**
        @memberof Plot
        @desc A pass-through to the underlying [Axis](http://d3plus.org/docs/#Axis) config used for the secondary y-axis. Includes additional functionality where passing "auto" as the value for the [scale](http://d3plus.org/docs/#Axis.scale) method will determine if the scale should be "linear" or "log" based on the provided data.
        @param {Object} *value*
        @chainable
    */

  }, {
    key: "y2Config",
    value: function y2Config(_) {
      if (arguments.length) {
        if (_.domain) _.domain = _.domain.slice().reverse();
        this._y2Config = assign(this._y2Config, _);
        return this;
      }

      return this._y2Config;
    }
    /**
        @memberof Plot
        @desc Sets the y domain to the specified array. If *value* is not specified, returns the current y domain. Additionally, if either value of the array is undefined, it will be calculated from the data.
        @param {Array} *value*
        @chainable
    */

  }, {
    key: "yDomain",
    value: function yDomain(_) {
      return arguments.length ? (this._yDomain = _, this) : this._yDomain;
    }
    /**
         @memberof Plot
         @desc Sets the y2 domain to the specified array. If *value* is not specified, returns the current y2 domain. Additionally, if either value of the array is undefined, it will be calculated from the data.
         @param {Array} *value*
         @chainable
     */

  }, {
    key: "y2Domain",
    value: function y2Domain(_) {
      return arguments.length ? (this._y2Domain = _, this) : this._y2Domain;
    }
    /**
        @memberof Plot
        @desc Defines a custom sorting comparitor function to be used for discrete y axes.
        @param {Function} *value*
        @chainable
    */

  }, {
    key: "ySort",
    value: function ySort(_) {
      return arguments.length ? (this._ySort = _, this) : this._ySort;
    }
    /**
         @memberof Plot
         @desc Defines a custom sorting comparitor function to be used for discrete y2 axes.
         @param {Function} *value*
         @chainable
     */

  }, {
    key: "y2Sort",
    value: function y2Sort(_) {
      return arguments.length ? (this._y2Sort = _, this) : this._y2Sort;
    }
  }]);

  return Plot;
}(Viz);

export { Plot as default };