import { max, min, sum } from "d3-array";
import { nest } from "d3-collection";
import discreteBuffer from "./discreteBuffer";
/**
    Adds a buffer to either side of the non-discrete axis.
    @param {Array} data
    @param {D3Scale} x
    @param {D3Scale} y
    @param {Object} [config]
    @param {Number} [buffer = 10]
    @private
*/

export default function (_ref) {
  var _this = this;

  var data = _ref.data,
      x = _ref.x,
      y = _ref.y,
      x2 = _ref.x2,
      y2 = _ref.y2,
      _ref$buffer = _ref.buffer,
      buffer = _ref$buffer === void 0 ? 10 : _ref$buffer;
  var xKey = x2 ? "x2" : "x";
  var yKey = y2 ? "y2" : "y";
  var oppScale = this._discrete === "x" ? y : x;
  var oppDomain = oppScale.domain().slice();
  var isDiscreteX = this._discrete === "x";
  if (isDiscreteX) oppDomain.reverse();
  var negVals, posVals;

  if (this._stacked) {
    var groupedData = nest().key(function (d) {
      return "".concat(d[_this._discrete], "_").concat(d.group);
    }).entries(data).map(function (d) {
      return d.values.map(function (x) {
        return x[isDiscreteX ? yKey : xKey];
      });
    });
    posVals = groupedData.map(function (arr) {
      return sum(arr.filter(function (d) {
        return d > 0;
      }));
    });
    negVals = groupedData.map(function (arr) {
      return sum(arr.filter(function (d) {
        return d < 0;
      }));
    });
  } else {
    posVals = data.map(function (d) {
      return d[isDiscreteX ? yKey : xKey];
    });
    negVals = posVals;
  }

  var bMax = oppScale(max(posVals));
  if (isDiscreteX ? bMax < oppScale(0) : bMax > oppScale(0)) bMax += isDiscreteX ? -buffer : buffer;
  bMax = oppScale.invert(bMax);
  var bMin = oppScale(min(negVals));
  if (isDiscreteX ? bMin > oppScale(0) : bMin < oppScale(0)) bMin += isDiscreteX ? buffer : -buffer;
  bMin = oppScale.invert(bMin);
  if (bMax > oppDomain[1]) oppDomain[1] = bMax;
  if (bMin < oppDomain[0]) oppDomain[0] = bMin;
  if (isDiscreteX) oppDomain.reverse();
  oppScale.domain(oppDomain);
  discreteBuffer(isDiscreteX ? x : y, data, this._discrete);
  return [x, y];
}