import discreteBuffer from "./discreteBuffer";
import numericBuffer from "./numericBuffer";
/**
    Adds a buffer to either side of the non-discrete axis.
    @param {Array} data
    @param {D3Scale} x
    @param {D3Scale} y
    @param {Object} [config]
    @param {Number} [buffer] Defaults to the width/height of the largest Rect.
    @private
*/

export default function (_ref) {
  var data = _ref.data,
      x = _ref.x,
      y = _ref.y,
      x2 = _ref.x2,
      y2 = _ref.y2,
      yScale = _ref.yScale,
      xScale = _ref.xScale,
      config = _ref.config;
  x = x.copy();
  y = y.copy();
  var xKey = x2 ? "x2" : "x";
  var yKey = y2 ? "y2" : "y";
  var xD = x.domain().slice(),
      yD = y.domain().slice();
  var xR = x.range(),
      yR = y.range();
  if (!x.invert && x.padding) discreteBuffer(x, data, this._discrete);
  if (!y.invert && y.padding) discreteBuffer(y, data, this._discrete);

  if (x.invert || y.invert) {
    data.forEach(function (d) {
      if (x.invert) {
        var w = config.width(d.data, d.i);
        xD = numericBuffer(x, xScale, d[xKey], w, xR, xD, 0, false);
        xD = numericBuffer(x, xScale, d[xKey], w, xR, xD, 1, false);
      }

      if (y.invert) {
        var h = config.height(d.data, d.i);
        yD = numericBuffer(y, yScale, d[yKey], h, yR, yD, 0, true);
        yD = numericBuffer(y, yScale, d[yKey], h, yR, yD, 1, true);
      }
    });
  }

  return [x, y];
}