function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
    @external Viz
    @see https://github.com/d3plus/d3plus-viz#Viz
*/
import { min, max, sum } from "d3-array";
import { nest } from "d3-collection";
import { pointer } from "d3-selection";
import { accessor, assign, configPrep, constant, elem, merge } from "d3plus-common";
import { Circle, Path, Rect } from "d3plus-shape";
import { Viz } from "d3plus-viz";
var tau = Math.PI * 2;
/**
    @class Radar
    @extends Viz
    @desc Creates a radar visualization based on an array of data.
*/

var Radar = /*#__PURE__*/function (_Viz) {
  _inherits(Radar, _Viz);

  var _super = _createSuper(Radar);

  /**
      @memberof Radar
      @desc Invoked when creating a new class instance, and overrides any default parameters inherited from Viz.
      @private
  */
  function Radar() {
    var _this;

    _classCallCheck(this, Radar);

    _this = _super.call(this);
    _this._axisConfig = {
      shapeConfig: {
        fill: constant("none"),
        labelConfig: {
          fontColor: "#999",
          padding: 0,
          textAnchor: function textAnchor(d, i, x) {
            return x.textAnchor;
          },
          verticalAlign: "middle"
        },
        stroke: "#eee",
        strokeWidth: constant(1)
      }
    };
    _this._discrete = "metric";
    _this._levels = 6;
    _this._metric = accessor("metric");
    _this._outerPadding = 100;
    _this._shape = constant("Path");
    _this._value = accessor("value");
    return _this;
  }
  /**
      Extends the draw behavior of the abstract Viz class.
      @private
  */


  _createClass(Radar, [{
    key: "_draw",
    value: function _draw(callback) {
      var _this2 = this;

      _get(_getPrototypeOf(Radar.prototype), "_draw", this).call(this, callback);

      var height = this._height - this._margin.top - this._margin.bottom,
          width = this._width - this._margin.left - this._margin.right;

      var radius = min([height, width]) / 2 - this._outerPadding,
          transform = "translate(".concat(width / 2, ", ").concat(height / 2, ")");

      var nestedAxisData = nest().key(this._metric).entries(this._filteredData),
          nestedGroupData = nest().key(this._id).key(this._metric).entries(this._filteredData);
      var maxValue = max(nestedGroupData.map(function (h) {
        return h.values.map(function (d) {
          return sum(d.values, function (x, i) {
            return _this2._value(x, i);
          });
        });
      }).flat());
      var circularAxis = Array.from(Array(this._levels).keys()).map(function (d) {
        return {
          id: d,
          r: radius * ((d + 1) / _this2._levels)
        };
      });
      var circleConfig = configPrep.bind(this)(this._axisConfig.shapeConfig, "shape", "Circle");
      delete circleConfig.label;
      new Circle().data(circularAxis).select(elem("g.d3plus-Radar-radial-circles", {
        parent: this._select,
        enter: {
          transform: transform
        },
        update: {
          transform: transform
        }
      }).node()).config(circleConfig).render();
      var totalAxis = nestedAxisData.length;
      var polarAxis = nestedAxisData.map(function (d, i) {
        var width = _this2._outerPadding;
        var fontSize = _this2._shapeConfig.labelConfig.fontSize && _this2._shapeConfig.labelConfig.fontSize(d, i) || 11;
        var lineHeight = fontSize * 1.4;
        var height = lineHeight * 2;
        var padding = 10,
            quadrant = parseInt(360 - 360 / totalAxis * i / 90, 10) % 4 + 1,
            radians = tau / totalAxis * i;
        var angle = 360 / totalAxis * i;
        var textAnchor = "start";
        var x = padding;

        if (quadrant === 2 || quadrant === 3) {
          x = -width - padding;
          textAnchor = "end";
          angle += 180;
        }

        var labelBounds = {
          x: x,
          y: -height / 2,
          width: width,
          height: height
        };
        return {
          __d3plus__: true,
          data: merge(d.values, _this2._aggs),
          i: i,
          id: d.key,
          angle: angle,
          textAnchor: textAnchor,
          labelBounds: labelBounds,
          rotateAnchor: [-x, height / 2],
          x: radius * Math.cos(radians),
          y: radius * Math.sin(radians)
        };
      }).sort(function (a, b) {
        return a.key - b.key;
      });
      new Rect().data(polarAxis).rotate(function (d) {
        return d.angle || 0;
      }).width(0).height(0).x(function (d) {
        return d.x;
      }).y(function (d) {
        return d.y;
      }).label(function (d) {
        return d.id;
      }).labelBounds(function (d) {
        return d.labelBounds;
      }).labelConfig(this._axisConfig.shapeConfig.labelConfig).select(elem("g.d3plus-Radar-text", {
        parent: this._select,
        enter: {
          transform: transform
        },
        update: {
          transform: transform
        }
      }).node()).render();
      new Path().data(polarAxis).d(function (d) {
        return "M".concat(0, ",", 0, " ", -d.x, ",").concat(-d.y);
      }).select(elem("g.d3plus-Radar-axis", {
        parent: this._select,
        enter: {
          transform: transform
        },
        update: {
          transform: transform
        }
      }).node()).config(configPrep.bind(this)(this._axisConfig.shapeConfig, "shape", "Path")).render();
      var groupData = nestedGroupData.map(function (h) {
        var q = h.values.map(function (d, i) {
          var value = sum(d.values, function (x, i) {
            return _this2._value(x, i);
          });
          var r = value / maxValue * radius,
              radians = tau / totalAxis * i;
          return {
            x: r * Math.cos(radians),
            y: r * Math.sin(radians)
          };
        });
        var d = "M ".concat(q[0].x, " ").concat(q[0].y, " ").concat(q.map(function (l) {
          return "L ".concat(l.x, " ").concat(l.y);
        }).join(" "), " L ").concat(q[0].x, " ").concat(q[0].y);
        return {
          arr: h.values.map(function (d) {
            return merge(d.values, _this2._aggs);
          }),
          id: h.key,
          points: q,
          d: d,
          __d3plus__: true,
          data: merge(h.values.map(function (d) {
            return merge(d.values, _this2._aggs);
          }), _this2._aggs)
        };
      });
      var pathConfig = configPrep.bind(this)(this._shapeConfig, "shape", "Path");
      var events = Object.keys(pathConfig.on);
      pathConfig.on = {};

      var _loop = function _loop(e) {
        var event = events[e];

        pathConfig.on[event] = function (d, i, s, e) {
          var x = d.points.map(function (p) {
            return p.x + width / 2;
          });
          var y = d.points.map(function (p) {
            return p.y + height / 2;
          });
          var cursor = pointer(e, _this2._select.node());
          var xDist = x.map(function (p) {
            return Math.abs(p - cursor[0]);
          });
          var yDist = y.map(function (p) {
            return Math.abs(p - cursor[1]);
          });
          var dists = xDist.map(function (d, i) {
            return d + yDist[i];
          });

          _this2._on[event].bind(_this2)(d.arr[dists.indexOf(min(dists))], i, s, e);
        };
      };

      for (var e = 0; e < events.length; e++) {
        _loop(e);
      }

      this._shapes.push(new Path().data(groupData).d(function (d) {
        return d.d;
      }).select(elem("g.d3plus-Radar-items", {
        parent: this._select,
        enter: {
          transform: transform
        },
        update: {
          transform: transform
        }
      }).node()).config(pathConfig).render());

      return this;
    }
    /**
        @memberof Radar
        @desc Sets the config method used for the radial spokes, circles, and labels.
        @param {Object} *value*
        @chainable
    */

  }, {
    key: "axisConfig",
    value: function axisConfig(_) {
      return arguments.length ? (this._axisConfig = assign(this._axisConfig, _), this) : this._axisConfig;
    }
    /**
        @memberof Radar
        @desc Defines the value used as axis. If *value* is specified, sets the accessor to the specified metric function. If *value* is not specified, returns the current metric accessor.
        @param {Function|String} *value*
        @chainable
    */

  }, {
    key: "metric",
    value: function metric(_) {
      return arguments.length ? (this._metric = typeof _ === "function" ? _ : accessor(_), this) : this._metric;
    }
    /**
        @memberof Radar
        @desc Determines how much pixel spaces to give the outer labels.
        @param {Number} [*value* = 100]
        @chainable
    */

  }, {
    key: "outerPadding",
    value: function outerPadding(_) {
      return arguments.length ? (this._outerPadding = _, this) : this._outerPadding;
    }
    /**
        @memberof Radar
        @desc If *value* is specified, sets the value accessor to the specified function or number and returns the current class instance. If *value* is not specified, returns the current value accessor.
        @param {Function|String} *value*
        @example
    function value(d) {
    return d.value;
    }
    */

  }, {
    key: "value",
    value: function value(_) {
      return arguments.length ? (this._value = typeof _ === "function" ? _ : accessor(_), this) : this._value;
    }
  }]);

  return Radar;
}(Viz);

export { Radar as default };