function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

import { Axis } from "d3plus-axis";
import { accessor, assign, configPrep, elem } from "d3plus-common";
import { Rect } from "d3plus-shape";
import { Viz } from "d3plus-viz";
import getProp from "./helpers/getProp";
import prepData from "./helpers/prepData";
var defaultAxisConfig = {
  align: "start",
  barConfig: {
    stroke: 0
  },
  gridSize: 0,
  padding: 5,
  paddingInner: 0,
  paddingOuter: 0,
  scale: "band",
  tickSize: 0
};
/**
    @class Matrix
    @extends Viz
    @desc Creates a simple rows/columns Matrix view of any dataset. See [this example](https://d3plus.org/examples/d3plus-matrix/getting-started/) for help getting started using the Matrix class.
*/

var Matrix = /*#__PURE__*/function (_Viz) {
  _inherits(Matrix, _Viz);

  var _super = _createSuper(Matrix);

  /**
    @memberof Matrix
    @desc Invoked when creating a new class instance, and sets any default parameters.
    @private
  */
  function Matrix() {
    var _this;

    _classCallCheck(this, Matrix);

    _this = _super.call(this);
    _this._cellPadding = 2;
    _this._column = accessor("column");
    _this._columnAxis = new Axis();
    _this._columnConfig = assign({
      orient: "top"
    }, defaultAxisConfig);

    _this._columnSort = function (a, b) {
      return "".concat(a).localeCompare("".concat(b));
    };

    _this._label = function (d, i) {
      return "".concat(getProp.bind(_assertThisInitialized(_this))("row", d, i), " / ").concat(getProp.bind(_assertThisInitialized(_this))("column", d, i));
    };

    var defaultMouseMoveShape = _this._on["mousemove.shape"];

    _this._on["mousemove.shape"] = function (d, i, x, event) {
      defaultMouseMoveShape(d, i, x, event);
      var row = getProp.bind(_assertThisInitialized(_this))("row", d, i);
      var column = getProp.bind(_assertThisInitialized(_this))("column", d, i);

      _this.hover(function (h, ii) {
        return getProp.bind(_assertThisInitialized(_this))("row", h, ii) === row || getProp.bind(_assertThisInitialized(_this))("column", h, ii) === column;
      });
    };

    _this._row = accessor("row");
    _this._rowAxis = new Axis();
    _this._rowConfig = assign({
      orient: "left"
    }, defaultAxisConfig);

    _this._rowSort = function (a, b) {
      return "".concat(a).localeCompare("".concat(b));
    };

    return _this;
  }
  /**
      @memberof Matrix
      @desc Extends the draw behavior of the abstract Viz class.
      @private
  */


  _createClass(Matrix, [{
    key: "_draw",
    value: function _draw(callback) {
      var _prepData$bind = prepData.bind(this)(this._filteredData),
          rowValues = _prepData$bind.rowValues,
          columnValues = _prepData$bind.columnValues,
          shapeData = _prepData$bind.shapeData;

      if (!rowValues.length || !columnValues.length) return this;
      var height = this._height - this._margin.top - this._margin.bottom,
          parent = this._select,
          transition = this._transition,
          width = this._width - this._margin.left - this._margin.right;
      var hidden = {
        opacity: 0
      };
      var visible = {
        opacity: 1
      };
      var columnRotation = width / columnValues.length < 120;

      var selectElem = function selectElem(name, opts) {
        return elem("g.d3plus-Matrix-".concat(name), Object.assign({
          parent: parent,
          transition: transition
        }, opts)).node();
      };

      this._rowAxis.select(selectElem("row", {
        enter: hidden,
        update: hidden
      })).domain(rowValues).height(height - this._margin.top - this._margin.bottom - this._padding.bottom - this._padding.top).maxSize(width / 4).width(width).config(this._rowConfig).render();

      var rowPadding = this._rowAxis.outerBounds().width;

      this._padding.left += rowPadding;
      var columnTransform = "translate(0, ".concat(this._margin.top, ")");
      var hiddenTransform = Object.assign({
        transform: columnTransform
      }, hidden);

      this._columnAxis.select(selectElem("column", {
        enter: hiddenTransform,
        update: hiddenTransform
      })).domain(columnValues).range([this._margin.left + this._padding.left, width - this._margin.right + this._padding.right]).height(height).maxSize(height / 4).width(width).labelRotation(columnRotation).config(this._columnConfig).render();

      var columnPadding = this._columnAxis.outerBounds().height;

      this._padding.top += columnPadding;

      _get(_getPrototypeOf(Matrix.prototype), "_draw", this).call(this, callback);

      var rowTransform = "translate(".concat(this._margin.left, ", ").concat(this._margin.top, ")");
      columnTransform = "translate(0, ".concat(this._margin.top, ")");
      var visibleTransform = Object.assign({
        transform: columnTransform
      }, visible);

      this._rowAxis.select(selectElem("row", {
        update: Object.assign({
          transform: rowTransform
        }, visible)
      })).height(height - this._margin.top - this._margin.bottom - this._padding.bottom).maxSize(rowPadding).range([columnPadding + this._columnAxis.padding(), undefined]).render();

      this._columnAxis.select(selectElem("column", {
        update: visibleTransform
      })).range([this._margin.left + this._padding.left + this._rowAxis.padding(), width - this._margin.right + this._padding.right]).maxSize(columnPadding).render();

      var rowScale = this._rowAxis._getPosition.bind(this._rowAxis);

      var columnScale = this._columnAxis._getPosition.bind(this._columnAxis);

      var cellHeight = rowValues.length > 1 ? rowScale(rowValues[1]) - rowScale(rowValues[0]) : this._rowAxis.height();
      var cellWidth = columnValues.length > 1 ? columnScale(columnValues[1]) - columnScale(columnValues[0]) : this._columnAxis.width();
      var transform = "translate(0, ".concat(this._margin.top, ")");
      var rectConfig = configPrep.bind(this)(this._shapeConfig, "shape", "Rect");

      this._shapes.push(new Rect().data(shapeData).select(elem("g.d3plus-Matrix-cells", {
        parent: this._select,
        enter: {
          transform: transform
        },
        update: {
          transform: transform
        }
      }).node()).config({
        height: cellHeight - this._cellPadding,
        width: cellWidth - this._cellPadding,
        x: function x(d) {
          return columnScale(d.column) + cellWidth / 2;
        },
        y: function y(d) {
          return rowScale(d.row) + cellHeight / 2;
        }
      }).config(rectConfig).render());

      return this;
    }
    /**
        @memberof Matrix
        @desc The pixel padding in between each cell.
        @param {Number} [*value* = 2]
    */

  }, {
    key: "cellPadding",
    value: function cellPadding(_) {
      return arguments.length ? (this._cellPadding = _, this) : this._cellPadding;
    }
    /**
        @memberof Matrix
        @desc Determines which key in your data should be used for each column in the matrix. Can be either a String that matches a key used in every data point, or an accessor function that receives a data point and it's index in the data array, and is expected to return it's column value.
        @param {String|Function} [*value*]
        @example
    function column(d) {
    return d.name;
    }
    */

  }, {
    key: "column",
    value: function column(_) {
      return arguments.length ? (this._column = typeof _ === "function" ? _ : accessor(_), this) : this._column;
    }
    /**
        @memberof Matrix
        @desc A pass-through to the underlying [Axis](http://d3plus.org/docs/#Axis) config used for the column labels.
        @param {Object} *value*
        @chainable
    */

  }, {
    key: "columnConfig",
    value: function columnConfig(_) {
      return arguments.length ? (this._columnConfig = assign(this._columnConfig, _), this) : this._columnConfig;
    }
    /**
        @memberof Matrix
        @desc A manual list of IDs to be used for columns.
        @param {Array} [*value*]
    */

  }, {
    key: "columnList",
    value: function columnList(_) {
      return arguments.length ? (this._columnList = _, this) : this._columnList;
    }
    /**
        @memberof Matrix
        @desc A sort comparator function that is run on the unique set of column values.
        @param {Function} [*value*]
        @example
    function column(a, b) {
    return a.localeCompare(b);
    }
    */

  }, {
    key: "columnSort",
    value: function columnSort(_) {
      return arguments.length ? (this._columnSort = _, this) : this._columnSort;
    }
    /**
        @memberof Matrix
        @desc Determines which key in your data should be used for each row in the matrix. Can be either a String that matches a key used in every data point, or an accessor function that receives a data point and it's index in the data array, and is expected to return it's row value.
        @param {String|Function} [*value*]
        @example
    function row(d) {
    return d.name;
    }
    */

  }, {
    key: "row",
    value: function row(_) {
      return arguments.length ? (this._row = typeof _ === "function" ? _ : accessor(_), this) : this._row;
    }
    /**
        @memberof Matrix
        @desc A pass-through to the underlying [Axis](http://d3plus.org/docs/#Axis) config used for the row labels.
        @param {Object} *value*
        @chainable
    */

  }, {
    key: "rowConfig",
    value: function rowConfig(_) {
      return arguments.length ? (this._rowConfig = assign(this._rowConfig, _), this) : this._rowConfig;
    }
    /**
        @memberof Matrix
        @desc A manual list of IDs to be used for rows.
        @param {Array} [*value*]
    */

  }, {
    key: "rowList",
    value: function rowList(_) {
      return arguments.length ? (this._rowList = _, this) : this._rowList;
    }
    /**
        @memberof Matrix
        @desc A sort comparator function that is run on the unique set of row values.
        @param {Function} [*value*]
        @example
    function row(a, b) {
    return a.localeCompare(b);
    }
    */

  }, {
    key: "rowSort",
    value: function rowSort(_) {
      return arguments.length ? (this._rowSort = _, this) : this._rowSort;
    }
  }]);

  return Matrix;
}(Viz);

export { Matrix as default };