function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

import { min } from "d3-array";
import { arc } from "d3-shape";
import { accessor, assign, configPrep, constant, elem } from "d3plus-common";
import { Path } from "d3plus-shape";
import { TextBox } from "d3plus-text";
import { Viz } from "d3plus-viz";
import getProp from "./helpers/getProp";
import prepData from "./helpers/prepData";
var tau = Math.PI * 2;
/**
    @class RadialMatrix
    @extends Viz
    @desc Creates a radial layout of a rows/columns Matrix of any dataset. See [this example](https://d3plus.org/examples/d3plus-matrix/radial-matrix/) for help getting started using the Matrix class.
*/

var RadialMatrix = /*#__PURE__*/function (_Viz) {
  _inherits(RadialMatrix, _Viz);

  var _super = _createSuper(RadialMatrix);

  /**
    @memberof RadialMatrix
    @desc Invoked when creating a new class instance, and sets any default parameters.
    @private
  */
  function RadialMatrix() {
    var _this;

    _classCallCheck(this, RadialMatrix);

    _this = _super.call(this);
    _this._cellPadding = 2;
    _this._column = accessor("column");
    _this._columnConfig = {
      shapeConfig: {
        labelConfig: {
          fontColor: "#000",
          padding: 5,
          textAnchor: function textAnchor(d) {
            return [0, 180].includes(d.angle) ? "middle" : [2, 3].includes(d.quadrant) ? "end" : "start";
          },
          verticalAlign: function verticalAlign(d) {
            return [90, 270].includes(d.angle) ? "middle" : [2, 1].includes(d.quadrant) ? "bottom" : "top";
          }
        }
      }
    };

    _this._columnSort = function (a, b) {
      return "".concat(a).localeCompare("".concat(b));
    };

    _this._innerRadius = function (radius) {
      return radius / 5;
    };

    _this._label = function (d, i) {
      return "".concat(getProp.bind(_assertThisInitialized(_this))("row", d, i), " / ").concat(getProp.bind(_assertThisInitialized(_this))("column", d, i));
    };

    var defaultMouseMoveShape = _this._on["mousemove.shape"];

    _this._on["mousemove.shape"] = function (d, i, x, event) {
      defaultMouseMoveShape(d, i, x, event);
      var row = getProp.bind(_assertThisInitialized(_this))("row", d, i);
      var column = getProp.bind(_assertThisInitialized(_this))("column", d, i);

      _this.hover(function (h, ii) {
        return getProp.bind(_assertThisInitialized(_this))("row", h, ii) === row || getProp.bind(_assertThisInitialized(_this))("column", h, ii) === column;
      });
    };

    _this._row = accessor("row");

    _this._rowSort = function (a, b) {
      return "".concat(a).localeCompare("".concat(b));
    };

    _this._columnLabels = new TextBox();
    return _this;
  }
  /**
      @memberof RadialMatrix
      @desc Extends the draw behavior of the abstract Viz class.
      @private
  */


  _createClass(RadialMatrix, [{
    key: "_draw",
    value: function _draw(callback) {
      var _this2 = this;

      var _prepData$bind = prepData.bind(this)(this._filteredData),
          rowValues = _prepData$bind.rowValues,
          columnValues = _prepData$bind.columnValues,
          shapeData = _prepData$bind.shapeData;

      if (!rowValues.length || !columnValues.length) return this;

      _get(_getPrototypeOf(RadialMatrix.prototype), "_draw", this).call(this, callback);

      var height = this._height - this._margin.top - this._margin.bottom,
          parent = this._select,
          transition = this._transition,
          width = this._width - this._margin.left - this._margin.right;
      var labelHeight = 50,
          labelWidth = 100;
      var radius = min([height - labelHeight * 2, width - labelWidth * 2]) / 2,
          transform = "translate(".concat(width / 2 + this._margin.left, ", ").concat(height / 2 + this._margin.top, ")");
      var flippedColumns = columnValues.slice().reverse();
      flippedColumns.unshift(flippedColumns.pop());
      var total = flippedColumns.length;
      var labelData = flippedColumns.map(function (key, i) {
        var radians = i / total * tau;
        var angle = Math.round(radians * 180 / Math.PI);
        var quadrant = Math.floor((angle + 90) / 90 % 4 + 1);
        var xMod = [0, 180].includes(angle) ? -labelWidth / 2 : [2, 3].includes(quadrant) ? -labelWidth : 0;
        var yMod = [90, 270].includes(angle) ? -labelHeight / 2 : [2, 1].includes(quadrant) ? -labelHeight : 0;
        return {
          key: key,
          angle: angle,
          quadrant: quadrant,
          radians: radians,
          x: radius * Math.sin(radians + Math.PI) + xMod,
          y: radius * Math.cos(radians + Math.PI) + yMod
        };
      });
      /**
       * Extracts the axis config "labels" Array, if it exists, it filters
       * the column labels by the values included in the Array.
       */

      var displayLabels = this._columnConfig.labels instanceof Array ? labelData.filter(function (d) {
        return _this2._columnConfig.labels.includes(d.key);
      }) : labelData;

      this._columnLabels.data(displayLabels).x(function (d) {
        return d.x;
      }).y(function (d) {
        return d.y;
      }).text(function (d) {
        return d.key;
      }).width(labelWidth).height(labelHeight).config(this._columnConfig.shapeConfig.labelConfig).select(elem("g.d3plus-RadialMatrix-columns", {
        parent: parent,
        transition: transition,
        enter: {
          transform: transform
        },
        update: {
          transform: transform
        }
      }).node()).render();

      var innerRadius = this._innerRadius(radius);

      var rowHeight = (radius - innerRadius) / rowValues.length;
      var columnWidth = labelData.length > 1 ? labelData[1].radians - labelData[0].radians : tau;
      var flippedRows = rowValues.slice().reverse();
      var arcData = arc().padAngle(this._cellPadding / radius).innerRadius(function (d) {
        return innerRadius + flippedRows.indexOf(d.row) * rowHeight + _this2._cellPadding / 2;
      }).outerRadius(function (d) {
        return innerRadius + (flippedRows.indexOf(d.row) + 1) * rowHeight - _this2._cellPadding / 2;
      }).startAngle(function (d) {
        return labelData[columnValues.indexOf(d.column)].radians - columnWidth / 2;
      }).endAngle(function (d) {
        return labelData[columnValues.indexOf(d.column)].radians + columnWidth / 2;
      });

      this._shapes.push(new Path().data(shapeData).d(arcData).select(elem("g.d3plus-RadialMatrix-arcs", {
        parent: parent,
        transition: transition,
        enter: {
          transform: transform
        },
        update: {
          transform: transform
        }
      }).node()).config({
        id: function id(d) {
          return _this2._ids(d).join("-");
        },
        x: 0,
        y: 0
      }).config(configPrep.bind(this)(this._shapeConfig, "shape", "Path")).render());

      return this;
    }
    /**
        @memberof RadialMatrix
        @desc The pixel padding in between each cell.
        @param {Number} [*value* = 2]
    */

  }, {
    key: "cellPadding",
    value: function cellPadding(_) {
      return arguments.length ? (this._cellPadding = _, this) : this._cellPadding;
    }
    /**
        @memberof RadialMatrix
        @desc Determines which key in your data should be used for each column in the matrix. Can be either a String that matches a key used in every data point, or an accessor function that receives a data point and it's index in the data array, and is expected to return it's column value.
        @param {String|Function} [*value*]
        @example
    function column(d) {
    return d.name;
    }
    */

  }, {
    key: "column",
    value: function column(_) {
      return arguments.length ? (this._column = typeof _ === "function" ? _ : accessor(_), this) : this._column;
    }
    /**
        @memberof RadialMatrix
        @desc A pass-through to the underlying [Axis](http://d3plus.org/docs/#Axis) config used for the column labels.
        @param {Object} *value*
        @chainable
    */

  }, {
    key: "columnConfig",
    value: function columnConfig(_) {
      return arguments.length ? (this._columnConfig = assign(this._columnConfig, _), this) : this._columnConfig;
    }
    /**
        @memberof RadialMatrix
        @desc A manual list of IDs to be used for columns.
        @param {Array} [*value*]
    */

  }, {
    key: "columnList",
    value: function columnList(_) {
      return arguments.length ? (this._columnList = _, this) : this._columnList;
    }
    /**
        @memberof RadialMatrix
        @desc A sort comparator function that is run on the unique set of column values.
        @param {Function} [*value*]
        @example
    function column(a, b) {
    return a.localeCompare(b);
    }
    */

  }, {
    key: "columnSort",
    value: function columnSort(_) {
      return arguments.length ? (this._columnSort = _, this) : this._columnSort;
    }
    /**
        @memberof RadialMatrix
        @desc The radius (in pixels) for the inner donut hole of the diagram. Can either be a static Number, or an accessor function that receives the outer radius as it's only argument.
        @param {Function|Number} [*value*]
        @example
    function(outerRadius) {
    return outerRadius / 5;
    }
    */

  }, {
    key: "innerRadius",
    value: function innerRadius(_) {
      return arguments.length ? (this._innerRadius = typeof _ === "function" ? _ : constant(_), this) : this._innerRadius;
    }
    /**
        @memberof RadialMatrix
        @desc Determines which key in your data should be used for each row in the matrix. Can be either a String that matches a key used in every data point, or an accessor function that receives a data point and it's index in the data array, and is expected to return it's row value.
        @param {String|Function} [*value*]
        @example
    function row(d) {
    return d.name;
    }
    */

  }, {
    key: "row",
    value: function row(_) {
      return arguments.length ? (this._row = typeof _ === "function" ? _ : accessor(_), this) : this._row;
    }
    /**
        @memberof RadialMatrix
        @desc A manual list of IDs to be used for rows.
        @param {Array} [*value*]
    */

  }, {
    key: "rowList",
    value: function rowList(_) {
      return arguments.length ? (this._rowList = _, this) : this._rowList;
    }
    /**
        @memberof RadialMatrix
        @desc A sort comparator function that is run on the unique set of row values.
        @param {Function} [*value*]
        @example
    function row(a, b) {
    return a.localeCompare(b);
    }
    */

  }, {
    key: "rowSort",
    value: function rowSort(_) {
      return arguments.length ? (this._rowSort = _, this) : this._rowSort;
    }
  }]);

  return RadialMatrix;
}(Viz);

export { RadialMatrix as default };