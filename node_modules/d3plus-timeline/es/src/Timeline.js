function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
    @external Axis
    @see https://github.com/d3plus/d3plus-axis#Axis
*/
import { max } from "d3-array";
import { brushX } from "d3-brush";
import { scaleTime } from "d3-scale";
import { pointer } from "d3-selection";
import { Axis, date } from "d3plus-axis";
import { colorDefaults } from "d3plus-color";
import { attrize, closest, elem } from "d3plus-common";
import { textWidth, textWrap } from "d3plus-text";
/**
    @class Timeline
    @extends external:Axis
*/

var Timeline = /*#__PURE__*/function (_Axis) {
  _inherits(Timeline, _Axis);

  var _super = _createSuper(Timeline);

  /**
      @memberof Timeline
      @desc Invoked when creating a new class instance, and overrides any default parameters inherited from Axis.
      @private
  */
  function Timeline() {
    var _this;

    _classCallCheck(this, Timeline);

    _this = _super.call(this);
    _this._barConfig = Object.assign({}, _this._barConfig, {
      "stroke-width": function strokeWidth() {
        return _this._buttonBehaviorCurrent === "buttons" ? 0 : 1;
      }
    });
    _this._brushing = true;

    _this._brushFilter = function (event) {
      return !event.button && event.detail < 2;
    };

    _this._buttonAlign = "middle";
    _this._buttonBehavior = "auto";
    _this._buttonPadding = 10;
    _this._buttonHeight = 30;
    _this._domain = [2001, 2010];
    _this._gridSize = 0;
    _this._handleConfig = {
      fill: colorDefaults.dark
    };
    _this._handleSize = 6;
    _this._height = 100;
    _this._labelOffset = false;
    _this._on = {};

    _this.orient("bottom");

    _this._scale = "time";
    _this._selectionConfig = {
      "fill": "#999",
      "stroke-width": 0
    };
    _this._shape = "Rect";
    _this._shapeConfig = Object.assign({}, _this._shapeConfig, {
      labelBounds: function labelBounds(d) {
        return _this._buttonBehaviorCurrent === "buttons" ? {
          x: d.labelBounds.x,
          y: -5,
          width: d.labelBounds.width,
          height: _this._buttonHeight
        } : d.labelBounds;
      },
      fill: function fill() {
        return _this._buttonBehaviorCurrent === "buttons" ? colorDefaults.light : colorDefaults.dark;
      },
      height: function height(d) {
        return _this._buttonBehaviorCurrent === "buttons" ? _this._buttonHeight : d.tick ? 10 : 0;
      },
      width: function width(d) {
        return _this._buttonBehaviorCurrent === "buttons" ? _this._ticksWidth / _this._availableTicks.length : d.tick ? _this._domain.map(function (t) {
          return date(t).getTime();
        }).includes(d.id) ? 2 : 1 : 0;
      },
      y: function y(d) {
        return _this._buttonBehaviorCurrent === "buttons" ? _this._align === "middle" ? _this._height / 2 : _this._align === "start" ? _this._margin.top + _this._buttonHeight / 2 : _this._height - _this._buttonHeight / 2 - _this._margin.bottom : d.y;
      }
    });
    _this._snapping = true;
    return _this;
  }
  /**
      @memberof Timeline
      @desc Triggered on brush "brush".
      @private
  */


  _createClass(Timeline, [{
    key: "_brushBrush",
    value: function _brushBrush(event) {
      if (event.sourceEvent && event.sourceEvent.offsetX && event.selection !== null && (!this._brushing || this._snapping)) {
        var domain = this._updateDomain(event);

        this._brushGroup.call(this._brush.move, this._updateBrushLimit(domain));
      }

      this._brushStyle();

      if (this._on.brush) this._on.brush(this._selection);
    }
    /**
        @memberof Timeline
        @desc Triggered on brush "end".
        @private
    */

  }, {
    key: "_brushEnd",
    value: function _brushEnd(event) {
      if (!event.sourceEvent) return; // Only transition after input.

      var domain = this._updateDomain(event);

      this._brushStyle();

      if (this._brushing || !this._snapping) this._brushGroup.transition(this._transition).call(this._brush.move, this._updateBrushLimit(domain));
      if (this._on.end) this._on.end(this._selection);
    }
    /**
        @memberof Timeline
        @desc Triggered on brush "start".
        @private
    */

  }, {
    key: "_brushStart",
    value: function _brushStart(event) {
      if (event.sourceEvent !== null && (!this._brushing || this._snapping)) {
        var domain = this._updateDomain(event);

        this._brushGroup.call(this._brush.move, this._updateBrushLimit(domain));
      }

      this._brushStyle();

      if (this._on.start) this._on.start(event);
    }
    /**
        @memberof Timeline
        @desc Overrides the default brush styles.
        @private
    */

  }, {
    key: "_brushStyle",
    value: function _brushStyle() {
      var height = this._position.height;
      var timelineHeight = this._shape === "Circle" ? typeof this._shapeConfig.r === "function" ? this._shapeConfig.r({
        tick: true
      }) * 2 : this._shapeConfig.r : this._shape === "Rect" ? typeof this._shapeConfig[height] === "function" ? this._shapeConfig[height]({
        tick: true
      }) : this._shapeConfig[height] : this._tickSize;

      var brushOverlay = this._brushGroup.selectAll(".overlay").attr("cursor", this._brushing ? "crosshair" : "pointer");

      var brushSelection = this._brushGroup.selectAll(".selection").call(attrize, this._selectionConfig).attr("height", timelineHeight);

      var brushHandle = this._brushGroup.selectAll(".handle").call(attrize, this._handleConfig).attr("height", this._buttonBehaviorCurrent === "buttons" ? this._buttonHeight : timelineHeight + this._handleSize);

      if (this._buttonBehaviorCurrent === "buttons") {
        var yTransform = this._align === "middle" ? this._height / 2 - this._buttonHeight / 2 : this._align === "start" ? this._margin.top : this._height - this._buttonHeight - this._margin.bottom;
        brushHandle.attr("y", yTransform);
        brushOverlay.attr("x", this._marginLeft).attr("width", this._ticksWidth);
        brushSelection.attr("y", yTransform);
      }
    }
    /**
        @memberof Timeline
        @desc Updates domain of the timeline used in brush functions.
        @private
    */

  }, {
    key: "_updateDomain",
    value: function _updateDomain(event) {
      var x = pointer(event, this._select.node())[0];
      var domain = event.selection && this._brushing ? event.selection : [x, x];
      if (this._buttonBehaviorCurrent === "ticks") domain = domain.map(this._d3Scale.invert);
      domain = domain.map(Number);

      if (event.type === "brush" && this._brushing && this._buttonBehaviorCurrent === "buttons") {
        var diffs = event.selection.map(function (d) {
          return Math.abs(d - event.sourceEvent.offsetX);
        });
        domain = diffs[1] <= diffs[0] ? [event.selection[0], event.sourceEvent.offsetX].sort(function (a, b) {
          return a - b;
        }) : [event.sourceEvent.offsetX, event.selection[1]].sort(function (a, b) {
          return a - b;
        });
      }

      var ticks = this._buttonBehaviorCurrent === "ticks" ? this._availableTicks.map(Number) : this._d3Scale.range();

      if (this._buttonBehaviorCurrent === "ticks") {
        domain[0] = date(closest(domain[0], ticks));
        domain[1] = date(closest(domain[1], ticks));
      } else {
        domain[0] = closest(domain[0], ticks);
        domain[1] = closest(domain[1], ticks);
      }

      var single = +domain[0] === +domain[1];

      if (event.type === "brush" || event.type === "end") {
        this._selection = this._buttonBehaviorCurrent === "ticks" ? single ? domain[0] : domain : single ? date(this._availableTicks[ticks.indexOf(domain[0])]) : [date(this._availableTicks[ticks.indexOf(domain[0])]), date(this._availableTicks[ticks.indexOf(domain[1])])];
      }

      return domain;
    }
    /**
        @memberof Timeline
        @desc Updates limits of the brush.
        @private
    */

  }, {
    key: "_updateBrushLimit",
    value: function _updateBrushLimit(domain) {
      var selection = this._buttonBehaviorCurrent === "ticks" ? domain.map(date).map(this._d3Scale) : domain;

      if (selection[0] === selection[1]) {
        selection[0] -= 0.1;
        selection[1] += 0.1;
      }

      if (this._buttonBehaviorCurrent === "buttons") {
        var buttonWidth = 0.5 * (this._ticksWidth / this._availableTicks.length - this._handleSize);
        selection[0] -= buttonWidth;
        selection[1] += buttonWidth;
      }

      return selection;
    }
    /**
        @memberof Timeline
        @desc Draws the timeline.
        @param {Function} [*callback* = undefined]
        @chainable
    */

  }, {
    key: "render",
    value: function render(callback) {
      var _this2 = this;

      var _this$_position = this._position,
          height = _this$_position.height,
          y = _this$_position.y;

      if (this._buttonBehavior !== "ticks") {
        var ticks = this._ticks ? this._ticks.map(date) : this._domain.map(date);
        var d3Scale = scaleTime().domain(ticks).range([0, this._width]);
        ticks = this._ticks ? ticks : d3Scale.ticks();
        if (!this._tickFormat) this._tickFormat = d3Scale.tickFormat(ticks.length - 1, this._tickSpecifier); // Measures size of ticks

        var maxLabel = 0;
        ticks.forEach(function (d, i) {
          var f = _this2._shapeConfig.labelConfig.fontFamily(d, i),
              s = _this2._shapeConfig.labelConfig.fontSize(d, i);

          var wrap = textWrap().fontFamily(f).fontSize(s).lineHeight(_this2._shapeConfig.lineHeight ? _this2._shapeConfig.lineHeight(d, i) : undefined);
          var res = wrap(d3Scale.tickFormat(ticks.length - 1, _this2._tickSpecifier)(d));
          var width = res.lines.length ? Math.ceil(max(res.lines.map(function (line) {
            return textWidth(line, {
              "font-family": f,
              "font-size": s
            });
          }))) + s / 4 : 0;
          if (width % 2) width++;
          if (maxLabel < width) maxLabel = width + 2 * _this2._buttonPadding;
        });
        this._ticksWidth = maxLabel * ticks.length;
      }

      this._buttonBehaviorCurrent = this._buttonBehavior === "auto" ? this._ticksWidth < this._width ? "buttons" : "ticks" : this._buttonBehavior;

      if (this._buttonBehaviorCurrent === "buttons") {
        this._scale = "ordinal";
        this._labelRotation = 0;
        if (!this._brushing) this._handleSize = 0;
        var domain = scaleTime().domain(this._domain.map(date)).ticks().map(this._tickFormat).map(Number);
        this._domain = this._ticks ? this._ticks.map(date) : Array.from(Array(domain[domain.length - 1] - domain[0] + 1), function (_, x) {
          return domain[0] + x;
        }).map(date);
        this._ticks = this._domain;
        var buttonMargin = 0.5 * this._ticksWidth / this._ticks.length;
        this._marginLeft = this._buttonAlign === "middle" ? (this._width - this._ticksWidth) / 2 : this._buttonAlign === "end" ? this._width - this._ticksWidth : 0;
        var marginRight = this._buttonAlign === "middle" ? (this._width + this._ticksWidth) / 2 : this._buttonAlign === "start" ? this._ticksWidth : undefined;
        this._range = [this._buttonAlign === "start" ? undefined : this._marginLeft + buttonMargin, this._buttonAlign === "end" ? undefined : marginRight - buttonMargin];
      }

      if (this._ticks) this._domain = this._buttonBehaviorCurrent === "ticks" ? [this._ticks[0], this._ticks[this._ticks.length - 1]] : this._ticks.map(date);
      this._labels = this._ticks;

      _get(_getPrototypeOf(Timeline.prototype), "render", this).call(this, callback);

      var offset = this._outerBounds[y],
          range = this._d3Scale.range();

      var brush = this._brush = brushX().extent([[range[0], offset], [range[range.length - 1], offset + this._outerBounds[height]]]).filter(this._brushFilter).handleSize(this._handleSize).on("start", this._brushStart.bind(this)).on("brush", this._brushBrush.bind(this)).on("end", this._brushEnd.bind(this));
      var latest = this._buttonBehaviorCurrent === "ticks" ? this._availableTicks[this._availableTicks.length - 1] : range[range.length - 1];
      var selection = this._selection === void 0 ? [latest, latest] : this._selection instanceof Array ? this._buttonBehaviorCurrent === "buttons" ? this._selection.map(function (d) {
        return range[_this2._ticks.map(Number).indexOf(+d)];
      }).slice() : this._selection.slice() : this._buttonBehaviorCurrent === "buttons" ? [range[this._ticks.map(Number).indexOf(+this._selection)], range[this._ticks.map(Number).indexOf(+this._selection)]] : [this._selection, this._selection];

      this._updateBrushLimit(selection);

      this._brushGroup = elem("g.brushGroup", {
        parent: this._group
      });

      this._brushGroup.call(brush).transition(this._transition).call(brush.move, this._buttonBehaviorCurrent === "ticks" ? this._updateBrushLimit(selection) : selection);

      this._outerBounds.y -= this._handleSize / 2;
      this._outerBounds.height += this._handleSize / 2;
      return this;
    }
    /**
          @memberof Timeline
          @desc If *value* is specified, sets the button padding and returns the current class instance. If *value* is not specified, returns the current button padding.
          @param {Number} [*value* = 10]
          @chainable
      */

  }, {
    key: "buttonPadding",
    value: function buttonPadding(_) {
      return arguments.length ? (this._buttonPadding = _, this) : this._buttonPadding;
    }
    /**
        @memberof Timeline
        @desc If *value* is specified, toggles the brushing value and returns the current class instance. If *value* is not specified, returns the current brushing value.
        @param {Boolean} [*value* = true]
        @chainable
    */

  }, {
    key: "brushing",
    value: function brushing(_) {
      return arguments.length ? (this._brushing = _, this) : this._brushing;
    }
    /**
        @memberof Timeline
        @desc If *value* is specified, sets the brush event filter and returns the current class instance. If *value* is not specified, returns the current brush event filter.
        @param {Function} [*value*]
        @chainable
        @example
    function() {
    return !event.button && event.detail < 2;
    }
    */

  }, {
    key: "brushFilter",
    value: function brushFilter(_) {
      return arguments.length ? (this._brushFilter = _, this) : this._brushFilter;
    }
    /**
        @memberof Timeline
        @desc If *value* is specified, toggles the horizontal alignment of the button timeline. Accepted values are `"start"`, `"middle"` and `"end"`. If *value* is not specified, returns the current button value.
        @param {String} [*value* = "middle"]
        @chainable
    */

  }, {
    key: "buttonAlign",
    value: function buttonAlign(_) {
      return arguments.length ? (this._buttonAlign = _, this) : this._buttonAlign;
    }
    /**
        @memberof Timeline
        @desc If *value* is specified, toggles the style of the timeline. Accepted values are `"auto"`, `"buttons"` and `"ticks"`. If *value* is not specified, returns the current button value.
        @param {String} [*value* = "auto"]
        @chainable
    */

  }, {
    key: "buttonBehavior",
    value: function buttonBehavior(_) {
      return arguments.length ? (this._buttonBehavior = _, this) : this._buttonBehavior;
    }
    /**
          @memberof Timeline
          @desc If *value* is specified, sets the button height and returns the current class instance. If *value* is not specified, returns the current button height.
          @param {Number} [*value* = 30]
          @chainable
      */

  }, {
    key: "buttonHeight",
    value: function buttonHeight(_) {
      return arguments.length ? (this._buttonHeight = _, this) : this._buttonHeight;
    }
    /**
        @memberof Timeline
        @desc If *value* is specified, sets the handle style and returns the current class instance. If *value* is not specified, returns the current handle style.
        @param {Object} [*value*]
        @chainable
    */

  }, {
    key: "handleConfig",
    value: function handleConfig(_) {
      return arguments.length ? (this._handleConfig = Object.assign(this._handleConfig, _), this) : this._handleConfig;
    }
    /**
        @memberof Timeline
        @desc If *value* is specified, sets the handle size and returns the current class instance. If *value* is not specified, returns the current handle size.
        @param {Number} [*value* = 6]
        @chainable
    */

  }, {
    key: "handleSize",
    value: function handleSize(_) {
      return arguments.length ? (this._handleSize = _, this) : this._handleSize;
    }
    /**
        @memberof Timeline
        @desc Adds or removes a *listener* for the specified brush event *typename*. If a *listener* is not specified, returns the currently-assigned listener for the specified event *typename*. Mirrors the core [d3-brush](https://github.com/d3/d3-brush#brush_on) behavior.
        @param {String|Object} [*typename*]
        @param {Function} [*listener*]
        @chainable
    */

  }, {
    key: "on",
    value: function on(_, f) {
      return arguments.length === 2 ? (this._on[_] = f, this) : arguments.length ? typeof _ === "string" ? this._on[_] : (this._on = Object.assign({}, this._on, _), this) : this._on;
    }
    /**
        @memberof Timeline
        @desc If *value* is specified, sets the selection style and returns the current class instance. If *value* is not specified, returns the current selection style.
        @param {Object} [*value*]
        @chainable
    */

  }, {
    key: "selectionConfig",
    value: function selectionConfig(_) {
      return arguments.length ? (this._selectionConfig = Object.assign(this._selectionConfig, _), this) : this._selectionConfig;
    }
    /**
        @memberof Timeline
        @desc If *value* is specified, sets the selection and returns the current class instance. If *value* is not specified, returns the current selection. Defaults to the most recent year in the timeline.
        @param {Array|Date|Number|String} [*value*]
        @chainable
    */

  }, {
    key: "selection",
    value: function selection(_) {
      return arguments.length ? (this._selection = _, this) : this._selection;
    }
    /**
        @memberof Timeline
        @desc If *value* is specified, toggles the snapping value and returns the current class instance. If *value* is not specified, returns the current snapping value.
        @param {Boolean} [*value* = true]
        @chainable
    */

  }, {
    key: "snapping",
    value: function snapping(_) {
      return arguments.length ? (this._snapping = _, this) : this._snapping;
    }
  }]);

  return Timeline;
}(Axis);

export { Timeline as default };