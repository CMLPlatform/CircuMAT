import { extent } from "d3-array";
import { date } from "d3plus-axis";
import { elem, unique } from "d3plus-common";
/**
    @function setTimeFilter
    @desc Determines whether or not to update the timeFilter method of the Viz.
    @param {Array|Date} The timeline selection given from the d3 brush.
    @private
*/

function setTimeFilter(s) {
  var _this = this;

  if (!(s instanceof Array)) s = [s, s];

  if (JSON.stringify(s) !== JSON.stringify(this._timelineSelection)) {
    this._timelineSelection = s;
    s = s.map(Number);
    this.timeFilter(function (d) {
      var ms = date(_this._time(d)).getTime();
      return ms >= s[0] && ms <= s[1];
    }).render();
  }
}
/**
    @function _drawTimeline
    @desc Renders the timeline if this._time and this._timeline are not falsy and there are more than 1 tick available.
    @param {Array} data The filtered data array to be displayed.
    @private
*/


export default function () {
  var _this2 = this;

  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var timelinePossible = this._time && this._timeline;
  var ticks = timelinePossible ? unique(this._data.map(this._time)).map(date) : [];
  timelinePossible = timelinePossible && ticks.length > 1;
  var padding = this._timelinePadding() ? this._padding : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  var transform = {
    transform: "translate(".concat(this._margin.left + padding.left, ", 0)")
  };
  var timelineGroup = elem("g.d3plus-viz-timeline", {
    condition: timelinePossible,
    enter: transform,
    parent: this._select,
    duration: this._duration,
    update: transform
  }).node();

  if (timelinePossible) {
    var timeline = this._timelineClass.domain(extent(ticks)).duration(this._duration).height(this._height - this._margin.bottom).locale(this._locale).select(timelineGroup).ticks(ticks.sort(function (a, b) {
      return +a - +b;
    })).width(this._width - (this._margin.left + this._margin.right + padding.left + padding.right));

    if (timeline.selection() === undefined) {
      this._timelineSelection = extent(data, this._time).map(date);
      timeline.selection(this._timelineSelection);
    }

    var config = this._timelineConfig;
    timeline.config(config) // .on("brush", s => {
    //   setTimeFilter.bind(this)(s);
    //   if (config.on && config.on.brush) config.on.brush(s);
    // })
    .on("end", function (s) {
      setTimeFilter.bind(_this2)(s);
      if (config.on && config.on.end) config.on.end(s);
    }).render();
    this._margin.bottom += timeline.outerBounds().height + timeline.padding() * 2;
  }
}