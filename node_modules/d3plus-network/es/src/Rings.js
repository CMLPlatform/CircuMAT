function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
    @external Viz
    @see https://github.com/d3plus/d3plus-viz#Viz
*/
import { extent, max, min } from "d3-array";
import { nest } from "d3-collection";
import * as scales from "d3-scale";
import { accessor, assign, configPrep, constant, elem } from "d3plus-common";
import { colorLegible } from "d3plus-color";
import * as shapes from "d3plus-shape";
import { addToQueue, Viz } from "d3plus-viz";
/**
    @class Rings
    @extends external:Viz
    @desc Creates a ring visualization based on a defined set of nodes and edges. [Click here](http://d3plus.org/examples/d3plus-network/simple-rings/) for help getting started using the Rings class.
*/

var Rings = /*#__PURE__*/function (_Viz) {
  _inherits(Rings, _Viz);

  var _super = _createSuper(Rings);

  /**
      @memberof Rings
      @desc Invoked when creating a new class instance, and sets any default parameters.
      @private
  */
  function Rings() {
    var _this;

    _classCallCheck(this, Rings);

    _this = _super.call(this);
    _this._links = [];
    _this._linkSize = constant(1);
    _this._linkSizeMin = 1;
    _this._linkSizeScale = "sqrt";
    _this._noDataMessage = false;
    _this._nodes = [];

    _this._on.mouseenter = function () {};

    _this._on["mouseleave.shape"] = function () {
      _this.hover(false);
    };

    var defaultMouseMove = _this._on["mousemove.shape"];

    _this._on["mousemove.shape"] = function (d, i, x, event) {
      defaultMouseMove(d, i, x, event);

      if (_this._focus && _this._focus === d.id) {
        _this.hover(false);

        _this._on.mouseenter.bind(_assertThisInitialized(_this))(d, i, x, event);

        _this._focus = undefined;
      } else {
        var id = _this._nodeGroupBy && _this._nodeGroupBy[_this._drawDepth](d, i) ? _this._nodeGroupBy[_this._drawDepth](d, i) : _this._id(d, i),
            links = _this._linkLookup[id],
            node = _this._nodeLookup[id];
        var filterIds = [node.id];
        var xDomain = [node.x - node.r, node.x + node.r],
            yDomain = [node.y - node.r, node.y + node.r];
        links.forEach(function (l) {
          filterIds.push(l.id);
          if (l.x - l.r < xDomain[0]) xDomain[0] = l.x - l.r;
          if (l.x + l.r > xDomain[1]) xDomain[1] = l.x + l.r;
          if (l.y - l.r < yDomain[0]) yDomain[0] = l.y - l.r;
          if (l.y + l.r > yDomain[1]) yDomain[1] = l.y + l.r;
        });

        _this.hover(function (h, x) {
          if (h.source && h.target) return h.source.id === node.id || h.target.id === node.id;else return filterIds.includes(_this._ids(h, x)[_this._drawDepth]);
        });
      }
    };

    _this._on["click.shape"] = function (d) {
      _this._center = d.id; // Need to resets margins and padding because we are
      // skipping over the default render method and using
      // _draw directly.

      _this._margin = {
        bottom: 0,
        left: 0,
        right: 0,
        top: 0
      };
      _this._padding = {
        bottom: 0,
        left: 0,
        right: 0,
        top: 0
      };

      _this._draw();
    };

    _this._sizeMin = 5;
    _this._sizeScale = "sqrt";
    _this._shape = constant("Circle");
    _this._shapeConfig = assign(_this._shapeConfig, {
      ariaLabel: function ariaLabel(d, i) {
        var validSize = _this._size ? ", ".concat(_this._size(d, i)) : "";
        return "".concat(_this._drawLabel(d, i)).concat(validSize, ".");
      },
      labelConfig: {
        duration: 0,
        fontMin: 1,
        fontResize: true,
        labelPadding: 0,
        textAnchor: "middle",
        verticalAlign: "middle"
      },
      Path: {
        fill: "none",
        label: false,
        stroke: "#eee",
        strokeWidth: 1
      }
    });
    return _this;
  }
  /**
      Extends the draw behavior of the abstract Viz class.
      @private
  */


  _createClass(Rings, [{
    key: "_draw",
    value: function _draw(callback) {
      var _this2 = this;

      _get(_getPrototypeOf(Rings.prototype), "_draw", this).call(this, callback);

      var data = this._filteredData.reduce(function (obj, d, i) {
        obj[_this2._id(d, i)] = d;
        return obj;
      }, {});

      var nodes = this._nodes;

      if (!this._nodes.length && this._links.length) {
        var nodeIds = Array.from(new Set(this._links.reduce(function (ids, link) {
          return ids.concat([link.source, link.target]);
        }, [])));
        nodes = nodeIds.map(function (node) {
          return _typeof(node) === "object" ? node : {
            id: node
          };
        });
      }

      nodes = nodes.reduce(function (obj, d, i) {
        obj[_this2._nodeGroupBy ? _this2._nodeGroupBy[_this2._drawDepth](d, i) : _this2._id(d, i)] = d;
        return obj;
      }, {});
      nodes = Array.from(new Set(Object.keys(data).concat(Object.keys(nodes)))).map(function (id, i) {
        var d = data[id],
            n = nodes[id];
        if (n === undefined) return false;
        return {
          __d3plus__: true,
          data: d || n,
          i: i,
          id: id,
          node: n,
          shape: d !== undefined && _this2._shape(d) !== undefined ? _this2._shape(d) : _this2._shape(n)
        };
      }).filter(function (n) {
        return n;
      });
      var nodeLookup = this._nodeLookup = nodes.reduce(function (obj, d) {
        obj[d.id] = d;
        return obj;
      }, {});

      var links = this._links.map(function (link) {
        var check = ["source", "target"];
        var edge = check.reduce(function (result, check) {
          result[check] = typeof link[check] === "number" ? nodes[link[check]] : nodeLookup[link[check].id || link[check]];
          return result;
        }, {});
        edge.size = _this2._linkSize(link);
        return edge;
      });

      var linkMap = links.reduce(function (map, link) {
        if (!map[link.source.id]) {
          map[link.source.id] = [];
        }

        map[link.source.id].push(link);

        if (!map[link.target.id]) {
          map[link.target.id] = [];
        }

        map[link.target.id].push(link);
        return map;
      }, {});
      var duration = this._duration,
          height = this._height - this._margin.top - this._margin.bottom,
          transform = "translate(".concat(this._margin.left, ", ").concat(this._margin.top, ")"),
          width = this._width - this._margin.left - this._margin.right;
      var edges = [],
          radius = min([height, width]) / 2,
          ringWidth = radius / 3;
      var primaryRing = ringWidth,
          secondaryRing = ringWidth * 2;
      var center = nodeLookup[this._center];
      center.x = width / 2;
      center.y = height / 2;
      center.r = this._sizeMin ? max([this._sizeMin, primaryRing * .65]) : this._sizeMax ? min([this._sizeMax, primaryRing * .65]) : primaryRing * .65;
      var claimed = [center],
          primaries = [];

      linkMap[this._center].forEach(function (edge) {
        var node = edge.source.id === _this2._center ? edge.target : edge.source;
        node.edges = linkMap[node.id].filter(function (link) {
          return link.source.id !== _this2._center || link.target.id !== _this2._center;
        });
        node.edge = edge;
        claimed.push(node);
        primaries.push(node);
      });

      primaries.sort(function (a, b) {
        return a.edges.length - b.edges.length;
      });
      var secondaries = [];
      var totalEndNodes = 0;
      primaries.forEach(function (p) {
        var primaryId = p.id;
        p.edges = p.edges.filter(function (edge) {
          return !claimed.includes(edge.source) && edge.target.id === primaryId || !claimed.includes(edge.target) && edge.source.id === primaryId;
        });
        totalEndNodes += p.edges.length || 1;
        p.edges.forEach(function (edge) {
          var source = edge.source,
              target = edge.target;
          var claim = target.id === primaryId ? source : target;
          claimed.push(claim);
        });
      });
      var tau = Math.PI * 2;
      var offset = 0;
      primaries.forEach(function (p, i) {
        var children = p.edges.length || 1;
        var space = tau / totalEndNodes * children;

        if (i === 0) {
          offset -= space / 2;
        }

        var angle = offset + space / 2 - tau / 4;
        p.radians = angle;
        p.x = width / 2 + primaryRing * Math.cos(angle);
        p.y = height / 2 + primaryRing * Math.sin(angle);
        offset += space;
        p.edges.forEach(function (edge, i) {
          var node = edge.source.id === p.id ? edge.target : edge.source;
          var s = tau / totalEndNodes;
          var a = angle - s * children / 2 + s / 2 + s * i;
          node.radians = a;
          node.x = width / 2 + secondaryRing * Math.cos(a);
          node.y = height / 2 + secondaryRing * Math.sin(a);
          secondaries.push(node);
        });
      });
      var primaryDistance = ringWidth / 2;
      var secondaryDistance = ringWidth / 4;
      var primaryMax = primaryDistance / 2 - 4;

      if (primaryDistance / 2 - 4 < 8) {
        primaryMax = min([primaryDistance / 2, 8]);
      }

      var secondaryMax = secondaryDistance / 2 - 4;

      if (secondaryDistance / 2 - 4 < 4) {
        secondaryMax = min([secondaryDistance / 2, 4]);
      }

      if (secondaryMax > ringWidth / 10) {
        secondaryMax = ringWidth / 10;
      }

      if (secondaryMax > primaryMax && secondaryMax > 10) {
        secondaryMax = primaryMax * .75;
      }

      if (primaryMax > secondaryMax * 1.5) {
        primaryMax = secondaryMax * 1.5;
      }

      primaryMax = Math.floor(primaryMax);
      secondaryMax = Math.floor(secondaryMax);
      var radiusFn;

      if (this._size) {
        var domain = extent(data, function (d) {
          return d.size;
        });

        if (domain[0] === domain[1]) {
          domain[0] = 0;
        }

        radiusFn = scales.scaleLinear().domain(domain).rangeRound([3, min([primaryMax, secondaryMax])]);
        var val = center.size;
        center.r = radiusFn(val);
      } else {
        radiusFn = scales.scaleLinear().domain([1, 2]).rangeRound([primaryMax, secondaryMax]);
      }

      secondaries.forEach(function (s) {
        s.ring = 2;
        var val = _this2._size ? s.size : 2;
        s.r = _this2._sizeMin ? max([_this2._sizeMin, radiusFn(val)]) : _this2._sizeMax ? min([_this2._sizeMax, radiusFn(val)]) : radiusFn(val);
      });
      primaries.forEach(function (p) {
        p.ring = 1;
        var val = _this2._size ? p.size : 1;
        p.r = _this2._sizeMin ? max([_this2._sizeMin, radiusFn(val)]) : _this2._sizeMax ? min([_this2._sizeMax, radiusFn(val)]) : radiusFn(val);
      });
      nodes = [center].concat(primaries).concat(secondaries);
      primaries.forEach(function (p) {
        var check = ["source", "target"];
        var edge = p.edge;
        check.forEach(function (node) {
          edge[node] = nodes.find(function (n) {
            return n.id === edge[node].id;
          });
        });
        edges.push(edge);
        linkMap[p.id].forEach(function (edge) {
          var node = edge.source.id === p.id ? edge.target : edge.source;

          if (node.id !== center.id) {
            var target = secondaries.find(function (s) {
              return s.id === node.id;
            });

            if (!target) {
              target = primaries.find(function (s) {
                return s.id === node.id;
              });
            }

            if (target) {
              edge.spline = true;
              var centerX = width / 2;
              var centerY = height / 2;
              var middleRing = primaryRing + (secondaryRing - primaryRing) * 0.5;
              var _check = ["source", "target"];

              _check.forEach(function (node, i) {
                edge["".concat(node, "X")] = edge[node].x + Math.cos(edge[node].ring === 2 ? edge[node].radians + Math.PI : edge[node].radians) * edge[node].r;
                edge["".concat(node, "Y")] = edge[node].y + Math.sin(edge[node].ring === 2 ? edge[node].radians + Math.PI : edge[node].radians) * edge[node].r;
                edge["".concat(node, "BisectX")] = centerX + middleRing * Math.cos(edge[node].radians);
                edge["".concat(node, "BisectY")] = centerY + middleRing * Math.sin(edge[node].radians);
                edge[node] = nodes.find(function (n) {
                  return n.id === edge[node].id;
                });
                if (edge[node].edges === undefined) edge[node].edges = {};
                var oppId = i === 0 ? edge.target.id : edge.source.id;

                if (edge[node].id === p.id) {
                  edge[node].edges[oppId] = {
                    angle: p.radians + Math.PI,
                    radius: ringWidth / 2
                  };
                } else {
                  edge[node].edges[oppId] = {
                    angle: target.radians,
                    radius: ringWidth / 2
                  };
                }
              });

              edges.push(edge);
            }
          }
        });
      });
      nodes.forEach(function (node) {
        if (node.id !== _this2._center) {
          var fontSize = _this2._shapeConfig.labelConfig.fontSize && _this2._shapeConfig.labelConfig.fontSize(node) || 11;
          var lineHeight = fontSize * 1.4;

          var _height = lineHeight * 2;

          var padding = 5;

          var _width = ringWidth - node.r;

          var angle = node.radians * (180 / Math.PI);
          var x = node.r + padding;
          var textAnchor = "start";

          if (angle < -90 || angle > 90) {
            x = -node.r - _width - padding;
            textAnchor = "end";
            angle += 180;
          }

          node.labelBounds = {
            x: x,
            y: -lineHeight / 2,
            width: _width,
            height: _height
          };
          node.rotate = angle;
          node.textAnchor = textAnchor;
        } else {
          node.labelBounds = {
            x: -primaryRing / 2,
            y: -primaryRing / 2,
            width: primaryRing,
            height: primaryRing
          };
        }
      });
      this._linkLookup = links.reduce(function (obj, d) {
        if (!obj[d.source.id]) obj[d.source.id] = [];
        obj[d.source.id].push(d.target);
        if (!obj[d.target.id]) obj[d.target.id] = [];
        obj[d.target.id].push(d.source);
        return obj;
      }, {});
      var strokeExtent = extent(links, function (d) {
        return d.size;
      });

      if (strokeExtent[0] !== strokeExtent[1]) {
        var _radius = min(nodes, function (d) {
          return d.r;
        });

        var strokeScale = scales["scale".concat(this._linkSizeScale.charAt(0).toUpperCase()).concat(this._linkSizeScale.slice(1))]().domain(strokeExtent).range([this._linkSizeMin, _radius]);
        links.forEach(function (link) {
          link.size = strokeScale(link.size);
        });
      }

      var linkConfig = configPrep.bind(this)(this._shapeConfig, "edge", "Path");
      delete linkConfig.on;

      this._shapes.push(new shapes.Path().config(linkConfig).strokeWidth(function (d) {
        return d.size;
      }).id(function (d) {
        return "".concat(d.source.id, "_").concat(d.target.id);
      }).d(function (d) {
        return d.spline ? "M".concat(d.sourceX, ",").concat(d.sourceY, "C").concat(d.sourceBisectX, ",").concat(d.sourceBisectY, " ").concat(d.targetBisectX, ",").concat(d.targetBisectY, " ").concat(d.targetX, ",").concat(d.targetY) : "M".concat(d.source.x, ",").concat(d.source.y, " ").concat(d.target.x, ",").concat(d.target.y);
      }).data(edges).select(elem("g.d3plus-rings-links", {
        parent: this._select,
        duration: duration,
        enter: {
          transform: transform
        },
        update: {
          transform: transform
        }
      }).node()).render());

      var that = this;
      var shapeConfig = {
        label: function label(d) {
          return nodes.length <= _this2._dataCutoff || _this2._hover && _this2._hover(d) || _this2._active && _this2._active(d) ? _this2._drawLabel(d.data || d.node, d.i) : false;
        },
        labelBounds: function labelBounds(d) {
          return d.labelBounds;
        },
        labelConfig: {
          fontColor: function fontColor(d) {
            return d.id === _this2._center ? configPrep.bind(that)(that._shapeConfig, "shape", d.key).labelConfig.fontColor(d) : colorLegible(configPrep.bind(that)(that._shapeConfig, "shape", d.key).fill(d));
          },
          fontResize: function fontResize(d) {
            return d.id === _this2._center;
          },
          padding: 0,
          textAnchor: function textAnchor(d) {
            return nodeLookup[d.id].textAnchor || configPrep.bind(that)(that._shapeConfig, "shape", d.key).labelConfig.textAnchor;
          },
          verticalAlign: function verticalAlign(d) {
            return d.id === _this2._center ? "middle" : "top";
          }
        },
        rotate: function rotate(d) {
          return nodeLookup[d.id].rotate || 0;
        },
        select: elem("g.d3plus-rings-nodes", {
          parent: this._select,
          duration: duration,
          enter: {
            transform: transform
          },
          update: {
            transform: transform
          }
        }).node()
      };
      nest().key(function (d) {
        return d.shape;
      }).entries(nodes).forEach(function (d) {
        _this2._shapes.push(new shapes[d.key]().config(configPrep.bind(_this2)(_this2._shapeConfig, "shape", d.key)).config(shapeConfig).data(d.values).render());
      });
      return this;
    }
    /**
     @memberof Rings
     @desc Sets the center node to be the node with the given id.
     @param {String}
     @chainable
     */

  }, {
    key: "center",
    value: function center(_) {
      return arguments.length ? (this._center = _, this) : this._center;
    }
    /**
        @memberof Rings
        @desc If *value* is specified, sets the hover method to the specified function and returns the current class instance.
        @param {Function} [*value*]
        @chainable
     */

  }, {
    key: "hover",
    value: function hover(_) {
      this._hover = _;

      this._shapes.forEach(function (s) {
        return s.hover(_);
      });

      if (this._legend) this._legendClass.hover(_);
      return this;
    }
    /**
        @memberof Rings
        @desc A predefined *Array* of edges that connect each object passed to the [node](#Rings.node) method. The `source` and `target` keys in each link need to map to the nodes in one of three ways:
    1. The index of the node in the nodes array (as in [this](http://d3plus.org/examples/d3plus-network/getting-started/) example).
    2. The actual node *Object* itself.
    3. A *String* value matching the `id` of the node.
    The value passed should either be an *Array* of data or a *String* representing a filepath or URL to be loaded. An optional formatting function can be passed as a second argument to this method. This custom function will be passed the data that has been loaded, as long as there are no errors. This function should return the final links *Array*.
        @param {Array|String} *links* = []
        @param {Function} [*formatter*]
        @chainable
    */

  }, {
    key: "links",
    value: function links(_, f) {
      if (arguments.length) {
        addToQueue.bind(this)(_, f, "links");
        return this;
      }

      return this._links;
    }
    /**
        @memberof Network
        @desc Defines the thickness of the links connecting each node. The value provided can be either a pixel Number to be used for all links, or an accessor function that returns a specific data value to be used in an automatically calculated linear scale.
        @param {Function|Name} [*value* = 1]
        @chainable
    */

  }, {
    key: "linkSize",
    value: function linkSize(_) {
      return arguments.length ? (this._linkSize = typeof _ === "function" ? _ : constant(_), this) : this._linkSize;
    }
    /**
        @memberof Network
        @desc Defines the minimum pixel stroke width used in link sizing.
        @param {Number} [*value* = 2]
        @chainable
    */

  }, {
    key: "linkSizeMin",
    value: function linkSizeMin(_) {
      return arguments.length ? (this._linkSizeMin = _, this) : this._linkSizeMin;
    }
    /**
        @memberof Network
        @desc Sets the specific type of [continuous d3-scale](https://github.com/d3/d3-scale#continuous-scales) used when calculating the pixel size of links in the network.
        @param {String} [*value* = "sqrt"]
        @chainable
    */

  }, {
    key: "linkSizeScale",
    value: function linkSizeScale(_) {
      return arguments.length ? (this._linkSizeScale = _, this) : this._linkSizeScale;
    }
    /**
        @memberof Rings
        @desc If *value* is specified, sets the node group accessor(s) to the specified string, function, or array of values and returns the current class instance. This method overrides the default .groupBy() function from being used with the data passed to .nodes(). If *value* is not specified, returns the current node group accessor.
        @param {String|Function|Array} [*value* = undefined]
        @chainable
    */

  }, {
    key: "nodeGroupBy",
    value: function nodeGroupBy(_) {
      var _this3 = this;

      if (!arguments.length) return this._nodeGroupBy;
      if (!(_ instanceof Array)) _ = [_];
      return this._nodeGroupBy = _.map(function (k) {
        if (typeof k === "function") return k;else {
          if (!_this3._aggs[k]) {
            _this3._aggs[k] = function (a, c) {
              var v = Array.from(new Set(a.map(c)));
              return v.length === 1 ? v[0] : v;
            };
          }

          return accessor(k);
        }
      }), this;
    }
    /**
        @memberof Rings
        @desc The list of nodes to be used for drawing the rings network. The value passed should either be an *Array* of data or a *String* representing a filepath or URL to be loaded.
    Additionally, a custom formatting function can be passed as a second argument to this method. This custom function will be passed the data that has been loaded, as long as there are no errors. This function should return the final node *Array*.
        @param {Array|String} *nodes* = []
        @param {Function} [*formatter*]
        @chainable
    */

  }, {
    key: "nodes",
    value: function nodes(_, f) {
      if (arguments.length) {
        addToQueue.bind(this)(_, f, "nodes");
        return this;
      }

      return this._nodes;
    }
    /**
        @memberof Rings
        @desc If *value* is specified, sets the size accessor to the specified function or data key and returns the current class instance. If *value* is not specified, returns the current size accessor.
        @param {Function|String} [*value*]
        @chainable
    */

  }, {
    key: "size",
    value: function size(_) {
      return arguments.length ? (this._size = typeof _ === "function" || !_ ? _ : accessor(_), this) : this._size;
    }
    /**
        @memberof Rings
        @desc If *value* is specified, sets the size scale maximum to the specified number and returns the current class instance. If *value* is not specified, returns the current size scale maximum. By default, the maximum size is determined by half the distance of the two closest nodes.
        @param {Number} [*value*]
        @chainable
    */

  }, {
    key: "sizeMax",
    value: function sizeMax(_) {
      return arguments.length ? (this._sizeMax = _, this) : this._sizeMax;
    }
    /**
        @memberof Rings
        @desc If *value* is specified, sets the size scale minimum to the specified number and returns the current class instance. If *value* is not specified, returns the current size scale minimum.
        @param {Number} [*value* = 5]
        @chainable
    */

  }, {
    key: "sizeMin",
    value: function sizeMin(_) {
      return arguments.length ? (this._sizeMin = _, this) : this._sizeMin;
    }
    /**
        @memberof Rings
        @desc If *value* is specified, sets the size scale to the specified string and returns the current class instance. If *value* is not specified, returns the current size scale.
        @param {String} [*value* = "sqrt"]
        @chainable
    */

  }, {
    key: "sizeScale",
    value: function sizeScale(_) {
      return arguments.length ? (this._sizeScale = _, this) : this._sizeScale;
    }
  }]);

  return Rings;
}(Viz);

export { Rings as default };