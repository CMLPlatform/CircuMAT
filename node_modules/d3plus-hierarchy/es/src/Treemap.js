function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

import { sum } from "d3-array";
import { nest } from "d3-collection";
import { hierarchy, treemap } from "d3-hierarchy";
import { treemapBinary, treemapDice, treemapSlice, treemapSliceDice, treemapSquarify, treemapResquarify } from "d3-hierarchy";
var tileMethods = {
  treemapBinary: treemapBinary,
  treemapDice: treemapDice,
  treemapSlice: treemapSlice,
  treemapSliceDice: treemapSliceDice,
  treemapSquarify: treemapSquarify,
  treemapResquarify: treemapResquarify
};
import { accessor, assign, configPrep, constant, elem, merge } from "d3plus-common";
import { formatAbbreviate } from "d3plus-format";
import { Rect } from "d3plus-shape";
import { Viz } from "d3plus-viz";
/**
    @class Treemap
    @extends Viz
    @desc Uses the [d3 treemap layout](https://github.com/mbostock/d3/wiki/Treemap-Layout) to creates SVG rectangles based on an array of data. See [this example](https://d3plus.org/examples/d3plus-hierarchy/getting-started/) for help getting started using the treemap generator.
*/

var Treemap = /*#__PURE__*/function (_Viz) {
  _inherits(Treemap, _Viz);

  var _super = _createSuper(Treemap);

  /**
    @memberof Treemap
    @desc Invoked when creating a new class instance, and sets any default parameters.
    @private
  */
  function Treemap() {
    var _this;

    _classCallCheck(this, Treemap);

    _this = _super.call(this);
    _this._layoutPadding = 1;
    var defaultLegend = _this._legend;

    _this._legend = function (config, arr) {
      if (arr.length === _this._filteredData.length) return false;
      return defaultLegend.bind(_assertThisInitialized(_this))(config, arr);
    };

    _this._legendSort = function (a, b) {
      return _this._sum(b) - _this._sum(a);
    };

    _this._legendTooltip = assign({}, _this._legendTooltip, {
      tbody: []
    });
    _this._shapeConfig = assign({}, _this._shapeConfig, {
      ariaLabel: function ariaLabel(d, i) {
        var rank = _this._rankData ? "".concat(_this._rankData.indexOf(d) + 1, ". ") : "";
        return "".concat(rank).concat(_this._drawLabel(d, i), ", ").concat(_this._sum(d, i), ".");
      },
      labelConfig: {
        fontMax: 40,
        fontMin: 8,
        fontResize: true,
        padding: 5
      }
    });

    _this._sort = function (a, b) {
      var aggA = isAggregated(a);
      var aggB = isAggregated(b);
      return aggA && !aggB ? 1 : !aggA && aggB ? -1 : b.value - a.value;
    };

    _this._sum = accessor("value");
    _this._thresholdKey = _this._sum;
    _this._tile = treemapSquarify;
    _this._tooltipConfig = assign({}, _this._tooltipConfig, {
      tbody: [[function () {
        return _this._translate("Share");
      }, function (d, i, x) {
        return "".concat(formatAbbreviate(x.share * 100, _this._locale), "%");
      }]]
    });
    _this._treemap = treemap().round(true);

    var isAggregated = function isAggregated(leaf) {
      return leaf.children && leaf.children.length === 1 && leaf.children[0].data._isAggregation;
    };

    return _this;
  }
  /**
      @memberof Treemap
      @desc Extends the draw behavior of the abstract Viz class.
      @private
  */


  _createClass(Treemap, [{
    key: "_draw",
    value: function _draw(callback) {
      var _this2 = this;

      _get(_getPrototypeOf(Treemap.prototype), "_draw", this).call(this, callback);

      var nestedData = nest();

      for (var i = 0; i <= this._drawDepth; i++) {
        nestedData.key(this._groupBy[i]);
      }

      nestedData = nestedData.entries(this._filteredData);

      var tmapData = this._treemap.padding(this._layoutPadding).size([this._width - this._margin.left - this._margin.right, this._height - this._margin.top - this._margin.bottom]).tile(this._tile)(hierarchy({
        values: nestedData
      }, function (d) {
        return d.values;
      }).sum(this._sum).sort(this._sort));

      var shapeData = [],
          that = this;
      /**
          @memberof Treemap
          @desc Flattens and merges treemap data.
          @private
      */

      function extractLayout(children) {
        for (var _i = 0; _i < children.length; _i++) {
          var node = children[_i];
          if (node.depth <= that._drawDepth) extractLayout(node.children);else {
            var index = node.data.values.length === 1 ? that._filteredData.indexOf(node.data.values[0]) : undefined;
            node.__d3plus__ = true;
            node.id = node.data.key;
            node.i = index > -1 ? index : undefined;
            node.data = merge(node.data.values, that._aggs);
            node.x = node.x0 + (node.x1 - node.x0) / 2;
            node.y = node.y0 + (node.y1 - node.y0) / 2;
            shapeData.push(node);
          }
        }
      }

      if (tmapData.children) extractLayout(tmapData.children);
      this._rankData = shapeData.sort(this._sort).map(function (d) {
        return d.data;
      });
      var total = tmapData.value;
      shapeData.forEach(function (d) {
        d.share = _this2._sum(d.data, d.i) / total;
      });
      var transform = "translate(".concat(this._margin.left, ", ").concat(this._margin.top, ")");
      var rectConfig = configPrep.bind(this)(this._shapeConfig, "shape", "Rect");
      var fontMax = rectConfig.labelConfig.fontMax;
      var fontMin = rectConfig.labelConfig.fontMin;
      var padding = rectConfig.labelConfig.padding;

      this._shapes.push(new Rect().data(shapeData).label(function (d) {
        return [_this2._drawLabel(d.data, d.i), "".concat(formatAbbreviate(d.share * 100, _this2._locale), "%")];
      }).select(elem("g.d3plus-Treemap", {
        parent: this._select,
        enter: {
          transform: transform
        },
        update: {
          transform: transform
        }
      }).node()).config({
        height: function height(d) {
          return d.y1 - d.y0;
        },
        labelBounds: function labelBounds(d, i, s) {
          var h = s.height;
          var sh = Math.min(fontMax, (h - padding * 2) * 0.5);
          if (sh < fontMin) sh = 0;
          return [{
            width: s.width,
            height: h - sh,
            x: -s.width / 2,
            y: -h / 2
          }, {
            width: s.width,
            height: sh + padding * 2,
            x: -s.width / 2,
            y: h / 2 - sh - padding * 2
          }];
        },
        labelConfig: {
          textAnchor: function textAnchor(d, i, x) {
            var line,
                parent = x;

            while (typeof line === "undefined" && parent) {
              if (typeof parent.l !== "undefined") line = parent.l;
              parent = parent.__d3plusParent__;
            }

            return line ? "middle" : "start";
          },
          verticalAlign: function verticalAlign(d, i, x) {
            var line,
                parent = x;

            while (typeof line === "undefined" && parent) {
              if (typeof parent.l !== "undefined") line = parent.l;
              parent = parent.__d3plusParent__;
            }

            return line ? "bottom" : "top";
          }
        },
        width: function width(d) {
          return d.x1 - d.x0;
        }
      }).config(rectConfig).render());

      return this;
    }
    /**
     * Applies the threshold algorithm for Treemaps.
     * @param {Array} data The data to process.
     * @private
     */

  }, {
    key: "_thresholdFunction",
    value: function _thresholdFunction(data) {
      var aggs = this._aggs;
      var drawDepth = this._drawDepth;
      var groupBy = this._groupBy;
      var threshold = this._threshold;
      var thresholdKey = this._thresholdKey;
      var totalSum = sum(data, thresholdKey);

      if (threshold && thresholdKey) {
        return thresholdByDepth(data, 0);
      }
      /**
       * @memberof Treemap
       * @desc Explores the data tree recursively and merges elements under the indicated threshold.
       * @param {object[]} branchData The current subset of the dataset to work on.
       * @param {number} depth The depth of the current branch.
       * @private
       */


      function thresholdByDepth(branchData, depth) {
        if (depth < drawDepth) {
          return nest().key(groupBy[depth]).entries(branchData).reduce(function (bulk, leaf) {
            var subBranchData = thresholdByDepth(leaf.values, depth + 1);
            return bulk.concat(subBranchData);
          }, []);
        }

        if (depth === drawDepth) {
          var thresholdPercent = Math.min(1, Math.max(0, threshold(branchData)));
          if (!isFinite(thresholdPercent) || isNaN(thresholdPercent)) return null;
          var removedItems = [];
          var branchDataCopy = branchData.slice();
          var thresholdValue = thresholdPercent * totalSum;
          var n = branchDataCopy.length;

          while (n--) {
            var datum = branchDataCopy[n];

            if (thresholdKey(datum) < thresholdValue) {
              var index = branchDataCopy.indexOf(datum);
              branchDataCopy.splice(index, 1);
              removedItems.push(datum);
            }
          }

          if (removedItems.length > 0) {
            var mergedItem = merge(removedItems, aggs);
            mergedItem._isAggregation = true;
            mergedItem._threshold = thresholdPercent;
            branchDataCopy.push(mergedItem);
          }

          return branchDataCopy;
        }

        throw new Error("Depth is higher than the amount of grouping levels.");
      }

      return data;
    }
    /**
        @memberof Treemap
        @desc If *value* is specified, sets the inner and outer padding accessor to the specified function or number and returns the current class instance. If *value* is not specified, returns the current padding accessor.
        @param {Function|Number} [*value*]
    */

  }, {
    key: "layoutPadding",
    value: function layoutPadding(_) {
      return arguments.length ? (this._layoutPadding = typeof _ === "function" ? _ : constant(_), this) : this._layoutPadding;
    }
    /**
        @memberof Treemap
        @desc If *comparator* is specified, sets the sort order for the treemap using the specified comparator function. If *comparator* is not specified, returns the current group sort order, which defaults to descending order by the associated input data's numeric value attribute.
        @param {Array} [*comparator*]
        @example
    function comparator(a, b) {
    return b.value - a.value;
    }
    */

  }, {
    key: "sort",
    value: function sort(_) {
      return arguments.length ? (this._sort = _, this) : this._sort;
    }
    /**
        @memberof Treemap
        @desc If *value* is specified, sets the sum accessor to the specified function or number and returns the current class instance. If *value* is not specified, returns the current sum accessor.
        @param {Function|Number} [*value*]
        @example
    function sum(d) {
    return d.sum;
    }
    */

  }, {
    key: "sum",
    value: function sum(_) {
      if (arguments.length) {
        this._sum = typeof _ === "function" ? _ : accessor(_);
        this._thresholdKey = this._sum;
        return this;
      } else return this._sum;
    }
    /**
        @memberof Treemap
        @desc Sets the tiling method used when calcuating the size and position of the rectangles.
    Can either be a string referring to a d3-hierarchy [tiling method](https://github.com/d3/d3-hierarchy#treemap-tiling), or a custom function in the same format.
        @param {String|Function} [*value* = "squarify"]
    */

  }, {
    key: "tile",
    value: function tile(_) {
      return arguments.length ? (this._tile = typeof _ === "string" ? tileMethods["treemap".concat(_.charAt(0).toUpperCase()).concat(_.slice(1))] || treemapSquarify : _, this) : this._tile;
    }
  }]);

  return Treemap;
}(Viz);

export { Treemap as default };